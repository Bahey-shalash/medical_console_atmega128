
AVRASM ver. 2.2.6  Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm Sat May 24 18:22:37 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(19): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(20): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\definitions.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(21): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\macros.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(27): warning: Register r14 already defined by the .DEF directive
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(72): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\lcd.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(73): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\printf.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(74): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\wire1.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(75): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_driver.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(76): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\encoder.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(77): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_helpers.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(82): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\home_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(83): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(84): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(85): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(86): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(19): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(20): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\definitions.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(21): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\macros.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(72): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\lcd.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(73): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\printf.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(74): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\wire1.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(75): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_driver.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(76): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\encoder.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(77): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_helpers.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(82): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\home_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(83): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(84): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(85): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(86): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm'
                                 
                                 ;======================================================================
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;  main.asm   ATmega128L @ 4 MHz  STK-300
                                 ;  Modular finite-state machine
                                 ;    WS2812 matrix on PD7  (driver)
                                 ;    LED-strip heartbeat on PF7 (active-low)
                                 ;    Buttons on PD0PD3 (INT0INT3)
                                 ;======================================================================
                                 ;
                                 ;  Register policy ----------------------------------------------------
                                 ;  r16 = w   : volatile scratch, clobbered by nearly every macro 
                                 ;              do **not** rely on its value except right after you
                                 ;              loaded it yourself and before the next macro call.
                                 ;  r17 = _w  : scratch inside interrupt prologues only.
                                 ;  r14 = s   : long-lived scratch for general calculations  never
                                 ;              touched by macros.  Preserve if you call sub-routines
                                 ;              that may use it.
                                 ;---------------------------------------------------------------------
                                 
                                             .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                             .include "definitions.asm"
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                             .include "macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 ;---------------------------------------------------------------------
                                 ;  Global registers / constants
                                 ;---------------------------------------------------------------------
                                             .def  sel = r6           ; current FSM state
                                             .def  s   = r14          ; stable scratch register
                                 
                                             .equ  FLG_TEMP   = 0     ; bit0 of `flags`   temperature-ready
                                             .equ  REG_STATES = 4     ; valid game states 03
                                             .equ  ST_HOME    = 0
                                             .equ  ST_GAME1   = 1
                                             .equ  ST_GAME2   = 2
                                             .equ  ST_GAME3   = 3
                                             .equ  ST_DOCTOR  = 4
                                 
                                             .equ  T1_PREH    = 0xF0  ; Timer-1 preload (high)
                                             .equ  T1_PREL    = 0xBE  ; Timer-1 preload (low)
                                             .equ  LED_BIT    = 7     ; PF7 heartbeat (active-low)
                                             .equ  BTN_DEBOUNCE = 50  ; Button debounce time in milliseconds
                                 ;---------------------------------------------------------------------
                                 ;  SRAM allocation
                                 ;---------------------------------------------------------------------
                                 .dseg
000100                           flags:      .byte 1            ; bit-flags (0 = FLG_TEMP)
000101                           temp_lsb:   .byte 1            ; DS18B20 LSB
000102                           temp_msb:   .byte 1            ; DS18B20 MSB
000103                           phase:      .byte 1            ; 0 = convert, 1 = read
                                 
                                 ;---------------------------------------------------------------------
                                 .cseg
                                 ;======================================================================
                                 ;  Interrupt vectors
                                 ;======================================================================
                                             .org 0
000000 940c 05f8                             jmp  reset
                                 
                                             .org INT0addr      ; next state
000002 940c 0664                             jmp  int0_isr
                                             .org INT1addr      ; previous state
000004 940c 066c                             jmp  int1_isr
                                             .org INT2addr      ; go home
000006 940c 0676                             jmp  int2_isr
                                             .org INT3addr      ; doctor mode
000008 940c 0678                             jmp  int3_isr
                                             .org OVF1addr      ; Timer-1 overflow
00001c 940c 067d                             jmp  t1_isr
                                 
                                 ;---------------------------------------------------------------------
                                 ;  Library / driver includes (after vectors)
                                 ;---------------------------------------------------------------------
                                             .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00001e 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
000020 fc37
000021 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000022 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000023 9300 8000                 	sts	LCD_IR, w		; store w in IR
000025 9508                      	ret
                                 	
                                 lcd_4us:
000026 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000027 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000028 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000029 302d
00002a f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
00002b 302a
00002c f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
00002d 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
00002f fd07
000030 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000031 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000032 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000034 9508                      	ret	
                                 	
000035 e001
000036 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
000037 e002
000038 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000039 e100
00003a cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
00003b e104
00003c cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
00003d e108
00003e cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
00003f e10c
000040 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000041 e00d
000042 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000043 e00c
000044 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000045 e00e
000046 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000047 e00c
000048 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000049 b705                      	in	w,MCUCR					; enable access to ext. SRAM
00004a 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
00004b bf05                      	out	MCUCR,w
00004c e001
00004d dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
00004e e006
00004f dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000050 e00c
000051 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000052 e308
000053 dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000054 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
000055 2f02                      	mov	w,a0
000056 6800                      	ori	w,0b10000000
000057 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000058 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
00005a fd07
00005b cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
00005c 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
00005d 6800                      	ori	w,0b10000000		; write address command
00005e dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
00005f 9300 8000                 	sts	LCD_IR,w			; store in IR
000061 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
000062 932f                      	push	a0				; safeguard a0
000063 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
000064 dff0                      	rcall	LCD_pos			; set cursor position
000065 912f                      	pop	a0					; restore a0
                                             .include "printf.asm"
000066 9508                      
                                 ; purpose library, formatted output generation
                                 ; v2019.02 20180821 supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000067 91ff
000068 91ef                      	POPZ			; z points to begin of "string"
000069 0fee
00006a 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
00006b 93af
00006c 93bf                      	PUSHX
                                 		
                                 _printf_read:
00006d 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00006e 9631                      	adiw	zl,1	; increment pointer Z
00006f 2000                      	tst	r0			; test for ZERO (=end of string)
000070 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
000071 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
000072 2d00                      	mov	w,r0
000073 d017                      	rcall	_putw	; display the character
000074 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000075 9631                      	adiw	zl,1	; point to the next character
000076 95f6
000077 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000078 91bf
000079 91af                      	POPX
00007a 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
00007b fa00                      	bst	r0,0		; store sign in T
00007c 2d00                      	mov	w,r0		; store formatting character in w
00007d 95c8                      	lpm	
00007e 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00007f 36a0                      	cpi	xl,0x60
000080 f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
000081 e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
000082 c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000083 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000084 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000085 3804
000086 f079                      	JK	w,FCHAR,_putchar
000087 3805
000088 f081                      	JK	w,FSTR ,_putstr
000089 c015                      	rjmp	_putnum
                                 	
00008a cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
00008b 932f
00008c 93ff
00008d 93ef                      	PUSH3	a0,zh,zl
00008e 2de4
00008f 2df5
000090 2f20                      	MOV3	a0,zh,zl, w,e1,e0
000091 9509                      	icall			; indirect call to "putc"
000092 91ef
000093 91ff
000094 912f                      	POP3	a0,zh,zl
000095 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000096 910c                      	ld	w,x
000097 dff3                      	rcall	_putw
000098 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000099 910d                      	ld	w,x+
00009a 2300                      	tst	w
00009b f409                      	brne	PC+2
00009c cfd0                      	rjmp	_printf_read
00009d dfed                      	rcall	_putw
00009e cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00009f 935f
0000a0 934f
0000a1 933f
0000a2 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
0000a3 939f
0000a4 938f
0000a5 937f
0000a6 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
0000a7 912d
0000a8 913d
0000a9 914d
0000aa 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
0000ab fd06
0000ac c006                      	JB1	w,6,_putdec
0000ad fd05
0000ae c00f                      	JB1	w,5,_putbin
0000af fd04
0000b0 c010                      	JB1	w,4,_puthex
0000b1 fd03
0000b2 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0000b3 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0000b4 2f70                      	mov	b1,w
0000b5 9576                      	lsr	b1
0000b6 7077                      	andi	b1,0b111	
0000b7 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000b8 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0000b9 2f90                      	mov	b3,w
0000ba 9592                      	swap	b3
0000bb 7093                      	andi	b3,0b11
0000bc 9593                      	inc	b3			; b3 = number of bytes (1..4)
0000bd c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0000be e062                      	ldi	b0,2		; b0 = base (2)
0000bf e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0000c0 c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0000c1 e160                      	ldi	b0,16		; b0 = base (16)
0000c2 e094                      	ldi	b3,4		; b3 = number of bytes (4)
0000c3 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0000c4 2f70                      	mov	b1,w
0000c5 9576                      	lsr	b1
0000c6 7077                      	andi	b1,0b111
0000c7 f409                      	brne	PC+2
0000c8 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0000c9 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000ca e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0000cb c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0000cc e06a                      	ldi	b0,10		; base=10	
0000cd 95c8                      	lpm
0000ce 2d80                      	mov	b2,r0		; load dec.point position
0000cf 9631                      	adiw	zl,1	; increment char pointer
0000d0 95c8                      	lpm
0000d1 2d70                      	mov	b1,r0		; load ii.ff format
0000d2 9631                      	adiw	zl,1	; increment char pointer
                                 	
0000d3 2f90                      	mov	b3,w
0000d4 9595                      	asr	b3
0000d5 7093                      	andi	b3,0b11
0000d6 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0000d7 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0000d8 3094
0000d9 f081                      	JK	b3,4,_printf_4b
0000da 3093
0000db f051                      	JK	b3,3,_printf_3b
0000dc 3092
0000dd f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0000de 2733                      	clr	a1
0000df f416                      	brtc	PC+3	; T=1 sign extension
0000e0 fd27                      	sbrc	a0,7
0000e1 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0000e2 2744                      	clr	a2
0000e3 f416                      	brtc	PC+3	; T=1 sign extension	
0000e4 fd37                      	sbrc	a1,7
0000e5 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0000e6 2755                      	clr	a3
0000e7 f416                      	brtc	PC+3	; T=1 sign extension
0000e8 fd47                      	sbrc	a2,7
0000e9 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0000ea d009                      	rcall	_ftoa		; float to ascii
0000eb 916f
0000ec 917f
0000ed 918f
0000ee 919f                      	POP4	b3,b2,b1,b0	; restore b
0000ef 912f
0000f0 913f
0000f1 914f
0000f2 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0000f3 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0000f4 92cf                      	push	d0
0000f5 92bf
0000f6 92af
0000f7 929f
0000f8 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0000f9 18bb
0000fa 24aa
0000fb 2499
0000fc 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0000fd f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0000fe 94e8                      	clt
0000ff 2355                      	tst	a3				; if MSb(a)=1 then a=-a
000100 f46a                      	brpl	_ftoa_plus
000101 9468                      	set					; T=1 (minus)
000102 2377                      	tst	b1
000103 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000104 5170                      	subi	b1,0x10		; decrease int digits
000105 9550
000106 9540
000107 9530
000108 9520
000109 ef0f
00010a 1b20
00010b 0b30
00010c 0b40
00010d 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
00010e 2388                      	tst	b2				; b0=0 (only integer part)
00010f f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
000110 9555
000111 9547
000112 9537
000113 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000114 94b7
000115 94a7
000116 9497
000117 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000118 958a
000119 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
00011a 937f                      	push	b1			; ii.ff (ii=int digits)
00011b 9572                      	swap	b1
00011c 707f                      	andi	b1,0x0f
                                 	
00011d e20e                      	ldi	w,'.'			; push decimal point
00011e 930f                      	push	w
                                 _ftoa_int1:
00011f d045                      	rcall	_div41		; int=int/10
000120 2d0c                      	mov	w,d0			; d=reminder
000121 d030                      	rcall	_hex2asc
000122 930f                      	push	w			; push rem(int/10)
000123 2700
000124 1720
000125 0730
000126 0740
000127 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000128 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000129 2377                      	tst	b1
00012a f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
00012b 957a
00012c f791                      	DJNZ	b1,_ftoa_int1
00012d c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00012e 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00012f f029                      	breq	_ftoa_sign
000130 957a                      	dec	b1
000131 f019                      	breq	_ftoa_sign
000132 e200                      	ldi	w,' '			; write spaces
000133 df57                      	rcall	_putw	
000134 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000135 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000136 e20d                      	ldi	w,'-'
000137 df53                      	rcall	_putw
                                 _ftoa_int3:
000138 910f                      	pop	w
000139 320e                      	cpi	w,'.'
00013a f011                      	breq	PC+3
00013b df4f                      	rcall	_putw
00013c cffb                      	rjmp	_ftoa_int3
                                 
00013d 917f                      	pop	b1				; ii.ff (ff=frac digits)
00013e 707f                      	andi	b1,0x0f
00013f 2377                      	tst	b1
000140 f059                      	breq	_ftoa_end
                                 _ftoa_point:	
000141 df49                      	rcall	_putw		; write decimal point
000142 2d28
000143 2d39
000144 2d4a
000145 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000146 d011                      	rcall	_mul41		; d.frac=10*frac
000147 2d0c                      	mov	w,d0
000148 d009                      	rcall	_hex2asc
000149 df41                      	rcall	_putw
00014a 957a
00014b f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
00014c 908f
00014d 909f
00014e 90af
00014f 90bf                      	POP4	c3,c2,c1,c0
000150 90cf                      	pop	d0
000151 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
000152 300a                      	cpi	w,10
000153 f410                      	brsh	PC+3
000154 5d00                      	addi	w,'0'
000155 9508                      	ret
000156 5a09                      	addi	w,('a'-10)
000157 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000158 24cc                      _mul41:	clr	d0			; clear byte4 of result
000159 e200                      	ldi	w,32			; load bit counter
00015a 9488                      __m41:	clc				; clear carry
00015b fd20                      	sbrc	a0,0		; skip addition if LSB=0
00015c 0ec6                      	add	d0,b0			; add b to MSB of a
00015d 94c7
00015e 9557
00015f 9547
000160 9537
000161 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
000162 950a
000163 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000164 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000165 24cc                      _div41:	clr	d0			; d will contain the remainder
000166 e200                      	ldi	w,32			; load bit counter
000167 1f22
000168 1f33
000169 1f44
00016a 1f55
00016b 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
00016c 1ac6                      	sub	d0, b0			; subtract b from remainder
00016d f408                      	brcc	PC+2	
00016e 0ec6                      	add	d0, b0			; restore if remainder became negative
00016f 950a
000170 f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
000171 1f22
000172 1f33
000173 1f44
000174 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000175 9550
000176 9540
000177 9530
000178 9520                      	COM4	a3,a2,a1,a0	; complement result
000179 9508                      	ret
                                             .include "wire1.asm"
                                 
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTB
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	cli                             ;  interrupts off
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	sei                           ; interrupts back on
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
00017a 950a                      	dec	w					; loop time 2usec
00017b 0000                      	nop
00017c 0000                      	nop
00017d 0000                      	nop
00017e 0000                      	nop
00017f 0000                      	nop
000180 f7c9                      	brne	wire1_wait
000181 9508                      	ret
                                 
                                 wire1_init:
000182 98c5                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000183 98bd                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000184 9508                      	ret
                                 	
000185 94f8
000186 9abd
000187 ef00
000188 dff1
000189 98bd
00018a e203
00018b dfee
00018c b306
00018d fb05
00018e ec0d
00018f dfea
000190 9478
000191 9508                      wire1_reset:	WIRE1	480,70,410
000192 94f8
000193 9abd
000194 e10c
000195 dfe4
000196 98bd
000197 e002
000198 dfe1
000199 b306
00019a fb05
00019b e001
00019c dfdd
00019d 9478
00019e 9508                      wire1_write0:	WIRE1	56,4,1
00019f 94f8
0001a0 9abd
0001a1 e001
0001a2 dfd7
0001a3 98bd
0001a4 e10e
0001a5 dfd4
0001a6 b306
0001a7 fb05
0001a8 e001
0001a9 dfd0
0001aa 9478
0001ab 9508                      wire1_write1:	WIRE1	1,59,1
0001ac 94f8
0001ad 9abd
0001ae e001
0001af dfca
0001b0 98bd
0001b1 e007
0001b2 dfc7
0001b3 b306
0001b4 fb05
0001b5 e107
0001b6 dfc3
0001b7 9478
0001b8 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
0001b9 933f                      	push	a1
0001ba e038                      	ldi	a1,8
0001bb 9527                      	ror	a0
                                 
0001bc f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
0001bd dfe1                      	rcall	wire1_write1
0001be c001                      	rjmp	PC+2
0001bf dfd2                      	rcall	wire1_write0
                                 
0001c0 953a
0001c1 f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
0001c2 913f                      	pop	a1	
0001c3 9508                      	ret
                                 
                                 wire1_read:
0001c4 933f                      	push	a1
0001c5 e038                      	ldi	a1,8
0001c6 9527                      	ror	a0
0001c7 dfe4                      	rcall	wire1_read1			; returns result in T
0001c8 f927                      	bld	a0,7					; move T to MSb
0001c9 953a
0001ca f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
0001cb 913f                      	pop	a1	
0001cc 9508                      	ret
                                 	
                                 wire1_crc:
0001cd e109                      	ldi	w,0b00011001
0001ce e048                      	ldi	a2,8
0001cf 9527                      crc1:	ror	a0
0001d0 f408                      	brcc	PC+2
0001d1 2730                      	eor	a1,w
0001d2 fb30                      	bst	a1,0
0001d3 9537                      	ror	a1
0001d4 f937                      	bld	a1,7
0001d5 954a
0001d6 f7c1                      	DJNZ	a2,crc1
0001d7 9508                      	ret
                                 
                                             .include "ws2812_driver.asm"
                                 
                                 ; purpose: reusable bit-bang driver + 88 XY helpers for WS2812B
                                 ;
                                 ; ????? ROUTINE REGISTER-USAGE SUMMARY (after this patch) ?????????????
                                 ;  routine         reads            clobbers (caller must save)       
                                 ; ?????????????????????????????????????????????????????????????????????
                                 ;  ws_init                                                          
                                 ;  ws_byte3wr      a0 a1 a2         a0 a1 a2          (u,w are saved) 
                                 ;  ws_reset                                                         
                                 ;  ws_idx_xy       r24 r25          r24 u                            
                                 ;  ws_offset_idx   r24              u w ZL ZH                        
                                 ;  (SREG always changes as any normal arithmetic will.)               
                                 ; ?????????????????????????????????????????????????????????????????????
                                 ; WS_PUSH_ALL    push every register any of the public helpers
                                 ;                    (ws_byte3wr, ws_idx_xy, ws_offset_idx) may change.
                                 ;   WS_POP_ALL     restore them in reverse order.
                                 ;
                                 ;  Use pattern
                                 ;       WS_PUSH_ALL
                                 ;           ;  build / send frame here 
                                 ;       WS_POP_ALL
                                 ; If your code needs a0a2 kept, push them before calling ws_byte3wr.
                                 ;
                                 ; ????? pin configuration (override before .include if you wish) ?????
                                 .equ WS_PORT_REG = PORTD
                                 .equ WS_DDR_REG  = DDRD
                                 .equ WS_PIN_IDX  = 7
                                 .equ WS_PIN_MASK = (1 << WS_PIN_IDX)
                                 
                                 .equ WS_BUF_BASE = 0x0400          ; 883-byte frame buffer
                                         .macro WS_PUSH_ALL
                                             push    a0
                                             push    a1
                                             push    a2
                                             push    u
                                             push    w
                                             push    r24
                                             push    r25
                                             push    ZH
                                             push    ZL
                                         .endm
                                 
                                         .macro WS_POP_ALL
                                             pop     ZL
                                             pop     ZH
                                             pop     r25
                                             pop     r24
                                             pop     w
                                             pop     u
                                             pop     a2
                                             pop     a1
                                             pop     a0
                                         .endm
                                 ; ????? timing-critical bit macros (4 MHz) ????????????????????????????
                                 ; 0 bit total ? 5 cycles (T0H ? 0.40 s, T0L ? 0.85 s)
                                 .macro WS_WR0
                                     clr  u                          ; u = 0  (destroys u **inside** routine)
                                     sbi  WS_PORT_REG, WS_PIN_IDX    ; high     (2 cy)
                                     out  WS_PORT_REG, u             ; low      (1 cy) full-port write
                                     nop                              ; 1 cy
                                     nop                              ; 1 cy
                                 .endm
                                 ; 1 bit total ? 8 cycles (T1H ? 0.80 s, T1L ? 0.45 s)
                                 .macro WS_WR1
                                     sbi  WS_PORT_REG, WS_PIN_IDX    ; high   (2 cy)
                                     nop                              ; 1 cy
                                     nop                              ; 1 cy
                                     cbi  WS_PORT_REG, WS_PIN_IDX    ; low    (2 cy)
                                 .endm
                                 
                                 ; ????????????????? PUBLIC ROUTINES ???????????????????????????????????
                                 
                                 ; set the data pin as output
                                 ws_init:
0001d8 e800
0001d9 bb01                          OUTI WS_DDR_REG, WS_PIN_MASK
0001da 9508                          ret
                                 
                                 ; bit-bang three bytes  (G=a0, R=a1, B=a2)
                                 ; u & w pushed so the caller never sees them modified
                                 ws_byte3wr:
0001db 923f                          push  u
0001dc 930f                          push  w
                                 
                                     ; ? byte G (a0) ?
0001dd e008                          ldi   w, 8
                                 _b0:
0001de fd27                          sbrc  a0, 7
0001df c006                              rjmp _b0_1
0001e0 2433
0001e1 9a97
0001e2 ba32
0001e3 0000
0001e4 0000                          WS_WR0
0001e5 c004                          rjmp  _b0_next
                                 _b0_1:
0001e6 9a97
0001e7 0000
0001e8 0000
0001e9 9897                          WS_WR1
                                 _b0_next:
0001ea 0f22                          lsl   a0
0001eb 950a                          dec   w
0001ec f789                          brne  _b0
                                 
                                     ; ? byte R (a1) ?
0001ed e008                          ldi   w, 8
                                 _b1:
0001ee fd37                          sbrc  a1, 7
0001ef c006                              rjmp _b1_1
0001f0 2433
0001f1 9a97
0001f2 ba32
0001f3 0000
0001f4 0000                          WS_WR0
0001f5 c004                          rjmp  _b1_next
                                 _b1_1:
0001f6 9a97
0001f7 0000
0001f8 0000
0001f9 9897                          WS_WR1
                                 _b1_next:
0001fa 0f33                          lsl   a1
0001fb 950a                          dec   w
0001fc f789                          brne  _b1
                                 
                                     ; ? byte B (a2) ?
0001fd e008                          ldi   w, 8
                                 _b2:
0001fe fd47                          sbrc  a2, 7
0001ff c006                              rjmp _b2_1
000200 2433
000201 9a97
000202 ba32
000203 0000
000204 0000                          WS_WR0
000205 c004                          rjmp  _b2_next
                                 _b2_1:
000206 9a97
000207 0000
000208 0000
000209 9897                          WS_WR1
                                 _b2_next:
00020a 0f44                          lsl   a2
00020b 950a                          dec   w
00020c f789                          brne  _b2
                                 
00020d 910f                          pop   w
00020e 903f                          pop   u
00020f 9508                          ret
                                 
                                 ; hold the data line low ?50 s to latch the frame
                                 ws_reset:
000210 9897                          cbi  WS_PORT_REG, WS_PIN_IDX
000211 e401
000212 2e30
000213 e001
000214 943a
000215 f7f1
000216 943a
000217 950a
000218 f7d9                          WAIT_US 50
000219 9508                          ret
                                 
                                 ; r24=x, r25=y  ? r24 = x + 8y   (clobbers u, r24)
                                 ws_idx_xy:
00021a 2e39                          mov  u, r25
00021b 0c33                          lsl  u
00021c 0c33                          lsl  u
00021d 0c33                          lsl  u
00021e 0d83                          add  r24, u
00021f 9508                          ret
                                 
                                 ; r24=index ? Z = WS_BUF_BASE + 3index  (clobbers u, w, ZL, ZH)
                                 ws_offset_idx:
000220 2f08                          mov  w, r24                  ; w = idx
000221 0f00                          lsl  w                       ; w = 2idx
000222 2e38                          mov  u, r24
000223 0d03                          add  w, u                    ; w = 3idx
000224 e0e0                          ldi  ZL, low (WS_BUF_BASE)
000225 e0f4                          ldi  ZH, high(WS_BUF_BASE)
000226 0fe0                          add  ZL, w
000227 2433                          clr  u
000228 1df3                          adc  ZH, u                   ; add carry
                                             .include "encoder.asm"
000229 9508                      
                                 ; purpose library angular encoder operation
                                 
                                 ; === definitions ===
                                 .equ	ENCOD	= PORTE
                                 
                                 .dseg
000104                           enc_old:.byte	1
                                 .cseg
                                 
                                 ; === routines ===
                                 
                                 encoder_init:
00022a b102                      	in	w,ENCOD-1		; make 3 lines input
00022b 780f                      	andi	w,0b10001111
00022c b902                      	out	ENCOD-1,w
00022d b103                      	in	w,ENCOD			; enable 3 internal pull-ups
00022e 6700                      	ori	w,0b01110000
00022f b903                      	out	ENCOD,w
000230 9508                      	ret
                                 
                                 encoder:
                                 ; a0,b0	if button=up   then increment/decrement a0	 
                                 ; a0,b0	if button=down then incremnt/decrement b0 
                                 ; T 	T=1 button press (transition up-down)
                                 ; Z	Z=1 button down change
                                 
000231 94e8                      	clt						; preclear T
000232 b111                      	in	_w,ENCOD-2			; read encoder port (_w=new)
                                 	
000233 7710                      	andi	_w,0b01110000	; mask encoder lines (A,B,I)
000234 9020 0104                 	lds	_u,enc_old			; load prevous value (_u=old)
000236 1512                      	cp	_w,_u				; compare new<>old ?
000237 f411                      	brne	PC+3
000238 9498                      	clz
000239 9508                      	ret						; if new=old then return (Z=0)
00023a 9310 0104                 	sts	enc_old,_w			; store encoder value for next time
                                 
00023c 2621                      	eor	_u,_w				; exclusive or detects transitions
00023d 9498                      	clz						; clear Z flag
00023e fc26                      	sbrc	_u,ENCOD_I
00023f c020                      	rjmp	encoder_button	; transition on I (button)
000240 fe24                      	sbrs	_u,ENCOD_A
000241 9508                      	ret						; return (no transition on I or A)	
                                 
000242 ff16                      	sbrs	_w,ENCOD_I		; is the button up or down ?
000243 c00b                      	rjmp	i_down
                                 i_up:	
000244 fd14                      	sbrc	_w,ENCOD_A
000245 c004                      	rjmp	a_rise
                                 a_fall:
000246 9523                      	inc	a0					; if B=1 then increment
000247 ff15                      	sbrs	_w,ENCOD_B
000248 5022                      	subi	a0,2			; if B=0 then decrement
000249 c003                      	rjmp	i_up_done
                                 a_rise:
00024a 9523                      	inc	a0					; if B=0 then increment
00024b fd15                      	sbrc	_w,ENCOD_B
00024c 5022                      	subi	a0,2			; if B=1 then decrement
                                 i_up_done:
00024d 9498                      	clz						; clear Z
00024e 9508                      	ret
                                 
                                 i_down:	
00024f fd14                      	sbrc	_w,ENCOD_A
000250 c004                      	rjmp	a_rise2
                                 a_fall2:
000251 9563                      	inc	b0					; if B=1 then increment
000252 ff15                      	sbrs	_w,ENCOD_B
000253 5062                      	subi	b0,2			; if B=0 then decrement
000254 c003                      	rjmp	i_down_done
                                 a_rise2:
000255 9563                      	inc	b0					; if B=0 then increment
000256 fd15                      	sbrc	_w,ENCOD_B
000257 5062                      	subi	b0,2			; if B=1 then decrement
                                 i_down_done:
000258 9418                      	sez						; set Z
000259 9508                      	ret
                                 
                                 encoder_update:
                                     ; save old a0
00025a 2f02                          mov r16, a0
                                 
                                     ; call the existing routine
00025b dfd5                          rcall encoder
                                 
                                     ; now a0 = new count, r16 = old count
00025c 2f12                          mov r17, a0
                                     ; compute ? = new ? old
00025d 1b10                          sub r17, r16       ; r17 = a0_new ? a0_old
00025e 2ef1                           mov  r15, r17        ; put result in r15, us
                                 
00025f 9508                          ret
                                 
                                 encoder_button:
000260 fd16                      	sbrc	_w,ENCOD_I
000261 c002                      	rjmp	i_rise
                                 i_fall:
000262 9468                      	set						; set T=1 to indicate button press
000263 9508                      	ret
                                 i_rise:
000264 9508                      	ret
                                 
                                 .macro	CYCLIC	;reg,lo,hi
                                 	cpi	@0,@1-1
                                 	brne	PC+2
                                 	ldi	@0,@2
                                 	cpi	@0,@2+1
                                 	brne	PC+2
                                 	ldi	@0,@1
                                 .endmacro
                                             .include "ws2812_helpers.asm"
                                 
                                 ;  ws2812_helpers.asm   solid-colour helper for the WS2812 88 matrix
                                 ;  call:  a0 = G  a1 = R  a2 = B   (GRB order)
                                 ;  clobbers:  Z, r0, r22, w=r16  (all scratch according to policy)
                                 ;======================================================================
                                 matrix_solid:
000265 936f                              push    r22
000266 93ef                              push    ZL
000267 93ff                              push    ZH
                                 
                                         ;--- fill frame buffer with the requested colour -------------
000268 e0e0                              ldi     ZL, low(WS_BUF_BASE)
000269 e0f4                              ldi     ZH, high(WS_BUF_BASE)
00026a e460                              ldi     r22, 64                    ; 64 pixels
                                 m_fill_loop:
00026b 9321                              st      Z+, a0
00026c 9331                              st      Z+, a1
00026d 9341                              st      Z+, a2
00026e 956a                              dec     r22
00026f f7d9                              brne    m_fill_loop
                                 
                                         ;--- transmit the frame to the LEDs --------------------------
000270 e0e0                              ldi     ZL, low(WS_BUF_BASE)
000271 e0f4                              ldi     ZH, high(WS_BUF_BASE)
000272 e400
000273 2e00                              _LDI    r0, 64
                                 m_send_loop:
000274 9121                              ld      a0, Z+
000275 9131                              ld      a1, Z+
000276 9141                              ld      a2, Z+
000277 94f8                              cli
000278 df62                              rcall   ws_byte3wr
000279 9478                              sei
00027a 940a                              dec     r0
00027b f7c1                              brne    m_send_loop
00027c df93                              rcall   ws_reset
                                 
00027d 91ff                              pop     ZH
00027e 91ef                              pop     ZL
00027f 916f                              pop     r22
000280 9508                      
                                 ;---------------------------------------------------------------------
                                 ;  State modules
                                 ;---------------------------------------------------------------------
                                             .include "home_state.asm"
                                 
                                 ;  HOME state   draw green background with holes off
                                 ;----------------------------------------------------------------------
                                 
                                 home_init:
000281 ddb3                              rcall   lcd_clear
000282 e209
000283 2e40
000284 e000
000285 2e50
000286 dde0                              PRINTF  LCD
000287 4f48
000288 454d
000289 0000                              .db     "HOME",0,0
                                 
                                         ; prepare green for fill (GRB = 0x0F,0x00,0x00)
00028a e02f                              ldi     a0, 0x0F     ; G
00028b e030                              ldi     a1, 0x00     ; R
00028c e040                              ldi     a2, 0x00     ; B
00028d d019                              rcall   matrix_holes
                                 
                                 home_wait:
00028e 2ce6                              mov     s, sel
00028f e000
000290 16e0                              _CPI    s, ST_HOME
000291 f4a1                              brne    home_done
000292 e302
000293 2e30
000294 e001
000295 930f
000296 923f
000297 e300
000298 2e30
000299 e006
00029a 943a
00029b f7f1
00029c 943a
00029d 950a
00029e f7d9
00029f 903f
0002a0 910f
0002a1 943a
0002a2 f791
0002a3 950a
0002a4 f781                              WAIT_MS 50
0002a5 cfe8                              rjmp    home_wait
                                 
                                 home_done:
0002a6 9508                              ret
                                 
                                 
                                 ;======================================================================
                                 ;  matrix_holes   fill 88 buffer green, then blank specified pixels
                                 ;  clobbers: a0a2, r0, r22, r24r25, Z, w=r16  (all scratch)
                                 ;======================================================================
                                 matrix_holes:
0002a7 936f                              push    r22
0002a8 93ef                              push    ZL
0002a9 93ff                              push    ZH
                                 
                                         ;--- 1) fill frame buffer 643=192 B with (a0,a1,a2) -----------
0002aa e0e0                              ldi     ZL, low(WS_BUF_BASE)
0002ab e0f4                              ldi     ZH, high(WS_BUF_BASE)
0002ac e460                              ldi     r22, 64
                                 mh_fill:
0002ad 9321                              st      Z+, a0
0002ae 9331                              st      Z+, a1
0002af 9341                              st      Z+, a2
0002b0 956a                              dec     r22
0002b1 f7d9                              brne    mh_fill
                                 
                                         ;--- 2) blank out holes by writing 0,0,0 at each coord --------
                                         ; (1,1)
0002b2 e081                              ldi     r24,1
0002b3 e091                              ldi     r25,1
0002b4 df65                              rcall   ws_idx_xy
0002b5 df6a                              rcall   ws_offset_idx
0002b6 9211                              st      Z+, r1
0002b7 9211                              st      Z+, r1
0002b8 8210                              st      Z,  r1
                                 
                                         ; (2,1)
0002b9 e082                              ldi     r24,2
0002ba e091                              ldi     r25,1
0002bb df5e                              rcall   ws_idx_xy
0002bc df63                              rcall   ws_offset_idx
0002bd 9211                              st      Z+, r1
0002be 9211                              st      Z+, r1
0002bf 8210                              st      Z,  r1
                                 
                                         ; (5,1)
0002c0 e085                              ldi     r24,5
0002c1 e091                              ldi     r25,1
0002c2 df57                              rcall   ws_idx_xy
0002c3 df5c                              rcall   ws_offset_idx
0002c4 9211                              st      Z+, r1
0002c5 9211                              st      Z+, r1
0002c6 8210                              st      Z,  r1
                                 
                                         ; (6,1)
0002c7 e086                              ldi     r24,6
0002c8 e091                              ldi     r25,1
0002c9 df50                              rcall   ws_idx_xy
0002ca df55                              rcall   ws_offset_idx
0002cb 9211                              st      Z+, r1
0002cc 9211                              st      Z+, r1
0002cd 8210                              st      Z,  r1
                                 
                                         ; (1,2)
0002ce e081                              ldi     r24,1
0002cf e092                              ldi     r25,2
0002d0 df49                              rcall   ws_idx_xy
0002d1 df4e                              rcall   ws_offset_idx
0002d2 9211                              st      Z+, r1
0002d3 9211                              st      Z+, r1
0002d4 8210                              st      Z,  r1
                                 
                                         ; (2,2)
0002d5 e082                              ldi     r24,2
0002d6 e092                              ldi     r25,2
0002d7 df42                              rcall   ws_idx_xy
0002d8 df47                              rcall   ws_offset_idx
0002d9 9211                              st      Z+, r1
0002da 9211                              st      Z+, r1
0002db 8210                              st      Z,  r1
                                 
                                         ; (5,2)
0002dc e085                              ldi     r24,5
0002dd e092                              ldi     r25,2
0002de df3b                              rcall   ws_idx_xy
0002df df40                              rcall   ws_offset_idx
0002e0 9211                              st      Z+, r1
0002e1 9211                              st      Z+, r1
0002e2 8210                              st      Z,  r1
                                 
                                         ; (6,2)
0002e3 e086                              ldi     r24,6
0002e4 e092                              ldi     r25,2
0002e5 df34                              rcall   ws_idx_xy
0002e6 df39                              rcall   ws_offset_idx
0002e7 9211                              st      Z+, r1
0002e8 9211                              st      Z+, r1
0002e9 8210                              st      Z,  r1
                                 
                                         ; (1,4)
0002ea e081                              ldi     r24,1
0002eb e094                              ldi     r25,4
0002ec df2d                              rcall   ws_idx_xy
0002ed df32                              rcall   ws_offset_idx
0002ee 9211                              st      Z+, r1
0002ef 9211                              st      Z+, r1
0002f0 8210                              st      Z,  r1
                                 
                                         ; (6,4)
0002f1 e086                              ldi     r24,6
0002f2 e094                              ldi     r25,4
0002f3 df26                              rcall   ws_idx_xy
0002f4 df2b                              rcall   ws_offset_idx
0002f5 9211                              st      Z+, r1
0002f6 9211                              st      Z+, r1
0002f7 8210                              st      Z,  r1
                                 
                                         ; (2,5)
0002f8 e082                              ldi     r24,2
0002f9 e095                              ldi     r25,5
0002fa df1f                              rcall   ws_idx_xy
0002fb df24                              rcall   ws_offset_idx
0002fc 9211                              st      Z+, r1
0002fd 9211                              st      Z+, r1
0002fe 8210                              st      Z,  r1
                                 
                                         ; (3,5)
0002ff e083                              ldi     r24,3
000300 e095                              ldi     r25,5
000301 df18                              rcall   ws_idx_xy
000302 df1d                              rcall   ws_offset_idx
000303 9211                              st      Z+, r1
000304 9211                              st      Z+, r1
000305 8210                              st      Z,  r1
                                 
                                         ; (4,5)
000306 e084                              ldi     r24,4
000307 e095                              ldi     r25,5
000308 df11                              rcall   ws_idx_xy
000309 df16                              rcall   ws_offset_idx
00030a 9211                              st      Z+, r1
00030b 9211                              st      Z+, r1
00030c 8210                              st      Z,  r1
                                 
                                         ; (5,5)
00030d e085                              ldi     r24,5
00030e e095                              ldi     r25,5
00030f df0a                              rcall   ws_idx_xy
000310 df0f                              rcall   ws_offset_idx
000311 9211                              st      Z+, r1
000312 9211                              st      Z+, r1
000313 8210                              st      Z,  r1
                                 
                                         ;--- 3) transmit the frame to the LEDs ------------------------
000314 e0e0                              ldi     ZL, low(WS_BUF_BASE)
000315 e0f4                              ldi     ZH, high(WS_BUF_BASE)
000316 e400
000317 2e00                              _LDI    r0, 64
                                 mh_send:
000318 9121                              ld      a0, Z+
000319 9131                              ld      a1, Z+
00031a 9141                              ld      a2, Z+
00031b 94f8                              cli
00031c debe                              rcall   ws_byte3wr
00031d 9478                              sei
00031e 940a                              dec     r0
00031f f7c1                              brne    mh_send
000320 deef                              rcall   ws_reset
                                 
000321 91ff                              pop     ZH
000322 91ef                              pop     ZL
000323 916f                              pop     r22
                                             .include "snake_state.asm"
000324 9508                      
                                 ;  SNAKE state  ST_GAME1 (cleaned up with constants)
                                 ;----------------------------------------------------------------------
                                 ;   88 WS2812 matrix
                                 ;   Growing snake  blue head / green body
                                 ;   Apple: red, re-spawns instantly at a random free cell when eaten
                                 ;   Walls: collision  GAME OVER (freeze until sel  ST_GAME1)
                                 ;   Control: rotary encoder (turns queued @ QUEUE_SIZE)
                                 ;   PRNG: read Timer-0 + ADC LSB (prescaler untouched)
                                 ;----------------------------------------------------------------------
                                 ;  Snake grows by +1 each time it eats an apple
                                 ;======================================================================
                                 
                                 ;---------------------------------------------------------------------
                                 ;  Symbolic constants
                                 ;---------------------------------------------------------------------
                                 .equ DIR_UPP              = 0
                                 .equ DIR_RIGHTT           = 1
                                 .equ DIR_DOWNN            = 2
                                 .equ DIR_LEFTT            = 3
                                 .equ DIR_INITT            = DIR_RIGHTT
                                 
                                 .equ Apple_INIT_POS       = 45
                                 
                                 .equ SNAKE_INIT_POS1      = 26
                                 .equ SNAKE_INIT_POS2      = 27
                                 .equ SNAKE_INIT_POS3      = 28
                                 .equ SNAKE_INIT_HEAD_IDX  = 2
                                 .equ SNAKE_INIT_LEN       = 3
                                 
                                 .equ FRAME_DELAY_MS       = 500
                                 
                                 .equ MATRIX_SIZE          = 8
                                 .equ GRID_CELLS           = MATRIX_SIZE * MATRIX_SIZE
                                 .equ COORD_MASK           = 0x07
                                 
                                 .equ QUEUE_SIZE           = 8
                                 .equ QUEUE_MASK           = QUEUE_SIZE - 1
                                 
                                 .equ APPLE_PLACEMENT_TRIES = 8
                                 
                                 .equ EMPTY_CELL           = 0xFF
                                 .equ BODY_GREEN           = 0x0F
                                 .equ HEAD_BLUE            = 0x0F
                                 .equ APPLE_RED            = 0x0F
                                 
                                 ;---------------------------------------------------------------------
                                 ;  SRAM layout
                                 ;---------------------------------------------------------------------
                                 .dseg
000105                           snake_body:   .byte GRID_CELLS      ; packed x + MATRIX_SIZE*y
000145                           head_idx:     .byte 1
000146                           tail_idx:     .byte 1
000147                           snake_len:    .byte 1
                                 
000148                           direction:    .byte 1               ; DIR_UPP..DIR_LEFTT
000149                           apple_pos:    .byte 1               ; EMPTY_CELL = no apple
                                 
00014a                           turn_queue:   .byte QUEUE_SIZE
000152                           tq_head:      .byte 1
000153                           tq_tail:      .byte 1
                                 .cseg
                                 
                                 ;=====================================================================
                                 ;  INITIALISATION
                                 ;=====================================================================
                                 snake_game_init:
000325 dd0f                          rcall lcd_clear
000326 e209
000327 2e40
000328 e000
000329 2e50
00032a dd3c                          PRINTF LCD
00032b 4e53
00032c 4b41
00032d 0045                          .db "SNAKE",0
                                 
00032e defb                          rcall encoder_init
00032f d002                          rcall snake_init_data
000330 d144                          rcall snake_draw
000331 c029                          rjmp snake_wait
                                 
                                 snake_init_data:
                                     ; clear body buffer  EMPTY_CELL
000332 e0e5                          ldi ZL, low(snake_body)
000333 e0f1                          ldi ZH, high(snake_body)
000334 e460                          ldi r22, GRID_CELLS
                                 clear_body:
000335 ef0f                          ldi w, EMPTY_CELL
000336 9301                          st  Z+, w
000337 956a                          dec r22
000338 f7e1                          brne clear_body
                                 
                                     ; seed snake at three positions
000339 e0e5                          ldi ZL, low(snake_body)
00033a e0f1                          ldi ZH, high(snake_body)
00033b e10a                          ldi w, SNAKE_INIT_POS1
00033c 9301                          st  Z+, w
00033d e10b                          ldi w, SNAKE_INIT_POS2
00033e 9301                          st  Z+, w
00033f e10c                          ldi w, SNAKE_INIT_POS3
000340 8300                          st  Z , w
                                 
                                     ; indices & length
000341 e002                          ldi w, SNAKE_INIT_HEAD_IDX
000342 9300 0145                     sts head_idx, w
000344 2700                          clr w
000345 9300 0146                     sts tail_idx, w
000347 e003                          ldi w, SNAKE_INIT_LEN
000348 9300 0147                     sts snake_len, w
                                 
                                     ; initial direction & apple
00034a e001                          ldi w, DIR_INITT
00034b 9300 0148                     sts direction, w
00034d e20d                          ldi w, Apple_INIT_POS
00034e 9300 0149                     sts apple_pos, w
                                 
                                     ; queue pointers
000350 2700                          clr w
000351 9300 0152                     sts tq_head, w
000353 9300 0153                     sts tq_tail, w
                                 
                                     ; encoder state
000355 2722                          clr a0
000356 2766                          clr b0
000357 b103                          in  w, ENCOD
000358 9300 0104                     sts enc_old, w
00035a 9508                          ret  ; Timer-0 prescaler untouched  PRNG read only
                                 
                                 ;=====================================================================
                                 ;  MAIN LOOP (fixed FRAME_DELAY_MS frames)
                                 ;=====================================================================
                                 snake_wait:
                                     ; start-of-frame delay
00035b ef84                          ldi r24, low(FRAME_DELAY_MS)
00035c e091                          ldi r25, high(FRAME_DELAY_MS)
                                 frame_delay:
00035d d01e                          rcall update_game
00035e e001
00035f 2e30
000360 e001
000361 930f
000362 923f
000363 e300
000364 2e30
000365 e006
000366 943a
000367 f7f1
000368 943a
000369 950a
00036a f7d9
00036b 903f
00036c 910f
00036d 943a
00036e f791
00036f 950a
000370 f781                          WAIT_MS 1
000371 9701                          sbiw r24, 1
000372 f751                          brne frame_delay
                                 
000373 d056                          rcall move_snake
000374 d100                          rcall snake_draw
                                 
                                     ; prepare next frame
000375 ef84                          ldi r24, low(FRAME_DELAY_MS)
000376 e091                          ldi r25, high(FRAME_DELAY_MS)
000377 2ce6                          mov s, sel
000378 e001
000379 16e0                          _CPI s, ST_GAME1
00037a f311                          breq frame_delay
00037b 9508                          ret
                                 
                                 ;=====================================================================
                                 ;  update_game  rotary encoder  heading  (unchanged)
                                 ;=====================================================================
                                 update_game:
00037c 939f                          push r25
00037d 938f                          push r24
00037e 932f                          push r18
00037f 933f                          push r19
000380 934f                          push r20
000381 935f                          push r21
000382 936f                          push r22
000383 937f                          push r23
                                 
000384 ded5                          rcall encoder_update        ; r15 = 1 or 0
000385 2d3f                          mov  r19, r15
000386 2333                          tst  r19
000387 f409                          brne enc_move
000388 c038                          rjmp enc_exit
                                 
                                 enc_move:
000389 9150 0148                     lds  r21, direction
00038b 2333                          tst  r19
00038c f032                          brmi enc_left
                                 
                                 enc_right:
00038d 2f45                          mov  r20, r21
00038e 9543                          inc  r20
00038f 3044                          cpi  r20, DIR_LEFTT+1
000390 f040                          brlo enc_chk
000391 2744                          clr  r20
000392 c006                          rjmp enc_chk
                                 
                                 enc_left:
000393 2f45                          mov  r20, r21
000394 2344                          tst  r20
000395 f411                          brne enc_left_ok
000396 e043                          ldi  r20, DIR_LEFTT
000397 c001                          rjmp enc_chk
                                 enc_left_ok:
000398 954a                          dec  r20
                                 
                                 enc_chk:                      ; reject 180
000399 2f65                          mov  r22, r21  ; r22 = old_direction
00039a 5f6e                          subi r22, -2     ; r22 = old_direction + 2
00039b 7063                          andi r22, 0x03  ; r22 = (old_direction + 2) & 0b11 = (old_direction + 2) mod 4
00039c 1746                          cp   r20, r22    ; compare new_direction to the 180-opposite
00039d f119                          breq enc_exit   ; if equal, reject the 180 turn
                                 
                                     ; enqueue
00039e 9170 0152                     lds  r23, tq_head
0003a0 2f87                          mov  r24, r23
0003a1 9583                          inc  r24
0003a2 7087                          andi r24, QUEUE_MASK
0003a3 9160 0153                     lds  r22, tq_tail
0003a5 1786                          cp   r24, r22
0003a6 f0d1                          breq enc_exit
                                 
0003a7 e4ea                          ldi  ZL, low(turn_queue)
0003a8 e0f1                          ldi  ZH, high(turn_queue)
0003a9 0fe7                          add  ZL, r23
0003aa f408                          brcc enc_store
0003ab 95f3                          inc  ZH
                                 enc_store:
0003ac 8340                          st   Z, r20
0003ad 9380 0152                     sts  tq_head, r24
                                 
                                     ; dequeue immediately
0003af 9160 0153                     lds  r22, tq_tail
0003b1 9170 0152                     lds  r23, tq_head
0003b3 1767                          cp   r22, r23
0003b4 f061                          breq enc_exit
                                 
0003b5 e4ea                          ldi  ZL, low(turn_queue)
0003b6 e0f1                          ldi  ZH, high(turn_queue)
0003b7 0fe6                          add  ZL, r22
0003b8 f408                          brcc enc_read
0003b9 95f3                          inc  ZH
                                 enc_read:
0003ba 8140                          ld   r20, Z
0003bb 9563                          inc  r22
0003bc 7067                          andi r22, QUEUE_MASK
0003bd 9360 0153                     sts  tq_tail, r22
0003bf 9340 0148                     sts  direction, r20
                                 
                                 enc_exit:
0003c1 917f                          pop  r23
0003c2 916f                          pop  r22
0003c3 915f                          pop  r21
0003c4 914f                          pop  r20
0003c5 913f                          pop  r19
0003c6 912f                          pop  r18
0003c7 918f                          pop  r24
0003c8 919f                          pop  r25
0003c9 9508                          ret
                                 
                                 ;=====================================================================
                                 ;  move_snake  borders, apple collision & growth
                                 ;=====================================================================
                                 move_snake:
0003ca 9120 0148                     lds  r18, direction
                                 
                                     ; fetch current head
0003cc 9130 0145                     lds  r19, head_idx
0003ce e0e5                          ldi  ZL, low(snake_body)
0003cf e0f1                          ldi  ZH, high(snake_body)
0003d0 0fe3                          add  ZL, r19
0003d1 f408                          brcc head_ptr
0003d2 95f3                          inc  ZH
                                 head_ptr:
0003d3 8140                          ld   r20, Z
                                 
                                     ; unpack x,y
0003d4 2f54                          mov  r21, r20
0003d5 7057                          andi r21, COORD_MASK
0003d6 2f64                          mov  r22, r20
0003d7 9566                          lsr  r22
0003d8 9566                          lsr  r22
0003d9 9566                          lsr  r22
0003da 7067                          andi r22, COORD_MASK
                                 
                                     ; border check & compute next cell
0003db 3021                          cpi  r18, DIR_RIGHTT
0003dc f041                          breq dir_right
0003dd 3023                          cpi  r18, DIR_LEFTT
0003de f051                          breq dir_left
0003df 3020                          cpi  r18, DIR_UPP
0003e0 f061                          breq dir_up
0003e1 9563                          inc  r22
0003e2 3068                          cpi  r22, MATRIX_SIZE
0003e3 f461                          brne pack_cell
0003e4 c039                          rjmp hit_wall
                                 
                                 dir_right:
0003e5 9553                          inc  r21
0003e6 3058                          cpi  r21, MATRIX_SIZE
0003e7 f441                          brne pack_cell
0003e8 c035                          rjmp hit_wall
                                 
                                 dir_left:
0003e9 2355                          tst  r21
0003ea f199                          breq hit_wall
0003eb 955a                          dec  r21
0003ec c003                          rjmp pack_cell
                                 
                                 dir_up:
0003ed 2366                          tst  r22
0003ee f179                          breq hit_wall
0003ef 956a                          dec  r22
                                 
                                 pack_cell:
                                     ; pack new head
0003f0 2f46                          mov  r20, r22
0003f1 0f44                          lsl  r20
0003f2 0f44                          lsl  r20
0003f3 0f44                          lsl  r20
0003f4 0f45                          add  r20, r21
                                 
                                     ; apple collision?
0003f5 9170 0149                     lds  r23, apple_pos
0003f7 3f7f                          cpi  r23, EMPTY_CELL
0003f8 f071                          breq write_head
0003f9 1747                          cp   r20, r23
0003fa f461                          brne write_head
                                 
                                     ; eat apple  reposition & grow
0003fb ef7f                          ldi  r23, EMPTY_CELL
0003fc 9370 0149                     sts  apple_pos, r23
0003fe d02f                          rcall place_new_apple
0003ff 9180 0147                     lds  r24, snake_len
000401 3480                          cpi  r24, GRID_CELLS
000402 f021                          breq write_head
000403 9583                          inc  r24
000404 9380 0147                     sts  snake_len, r24
000406 c008                          rjmp write_head_no_tail
                                 
                                 write_head:
                                     ; advance tail normally
000407 9150 0146                     lds  r21, tail_idx
000409 9553                          inc  r21
00040a 3450                          cpi  r21, GRID_CELLS
00040b f008                          brlo tail_ok
00040c 2755                          clr  r21
                                 tail_ok:
00040d 9350 0146                     sts  tail_idx, r21
                                 
                                 write_head_no_tail:
                                     ; advance head index & write new head
00040f 9130 0145                     lds  r19, head_idx
000411 9533                          inc  r19
000412 3430                          cpi  r19, GRID_CELLS
000413 f008                          brlo idx_ok_write
000414 2733                          clr  r19
                                 idx_ok_write:
000415 9330 0145                     sts  head_idx, r19
000417 e0e5                          ldi  ZL, low(snake_body)
000418 e0f1                          ldi  ZH, high(snake_body)
000419 0fe3                          add  ZL, r19
00041a f408                          brcc write_ptr
00041b 95f3                          inc  ZH
                                 write_ptr:
00041c 8340                          st   Z, r20
00041d 9508                          ret
                                 
                                 hit_wall:
00041e dc16                          rcall lcd_clear
00041f e209
000420 2e40
000421 e000
000422 2e50
000423 dc43                          PRINTF LCD
000424 4147
000425 454d
000426 4f20
000427 4556
000428 0052                          .db "GAME OVER",0
                                 freeze_game:
000429 2d26                          mov  r18, sel
00042a e001
00042b 1720                          _CPI r18, ST_GAME1
00042c f3e1                          breq freeze_game
00042d 9508                          ret
                                 
                                 ;=====================================================================
                                 ;  place_new_apple  constant-time (8 passes)
                                 ;=====================================================================
                                 place_new_apple:
00042e 93af                          push r26
00042f 939f                          push r25
000430 938f                          push r24
000431 937f                          push r23
000432 936f                          push r22
000433 935f                          push r21
000434 934f                          push r20
000435 933f                          push r19
000436 932f                          push r18
                                 
000437 2722                          clr   r18                ; first free candidate marker
000438 e078                          ldi   r23, APPLE_PLACEMENT_TRIES
                                 
                                 loop_iter:
                                     ; PRNG candidate
000439 b782                          in    r24, TCNT0
00043a b1a4                          in    r26, ADCL
00043b 278a                          eor   r24, r26
00043c 9130 0145                     lds   r19, head_idx
00043e 0f83                          add   r24, r19
                                 
00043f 2f98                          mov   r25, r24
000440 7087                          andi  r24, COORD_MASK
000441 9596                          lsr   r25
000442 9596                          lsr   r25
000443 9596                          lsr   r25
000444 7097                          andi  r25, COORD_MASK
                                 
000445 2f49                          mov   r20, r25
000446 0f44                          lsl   r20
000447 0f44                          lsl   r20
000448 0f44                          lsl   r20
000449 0f48                          add   r20, r24
                                 
                                     ; compare against all snake segments
00044a 9160 0146                     lds   r22, tail_idx
00044c 9180 0147                     lds   r24, snake_len
00044e 2755                          clr   r21               ; i = 0
                                 scan_loop:
00044f 1758                          cp    r21, r24
000450 f081                          breq  free_found
000451 2f16                          mov   _w, r22
000452 0f15                          add   _w, r21
000453 3410                          cpi   _w, GRID_CELLS
000454 f008                          brlo  idx_ok
000455 5410                          subi  _w, GRID_CELLS
                                 idx_ok:
000456 e0e5                          ldi   ZL, low(snake_body)
000457 e0f1                          ldi   ZH, high(snake_body)
000458 0fe1                          add   ZL, _w
000459 f408                          brcc buf_ptr
00045a 95f3                          inc   ZH
                                 buf_ptr:
00045b 8110                          ld    _w, Z
00045c 1714                          cp    _w, r20
00045d f011                          breq clash_found
00045e 9553                          inc   r21
00045f cfef                          rjmp  scan_loop
                                 
                                 clash_found:
                                     ; segment clash  skip storing
000460 c003                          rjmp loop_continue
                                 
                                 free_found:
000461 2322                          tst   r18
000462 f409                          brne loop_continue
000463 2f24                          mov   r18, r20
                                 
                                 loop_continue:
000464 957a                          dec   r23
000465 f699                          brne  loop_iter
                                 
                                     ; commit result
000466 2322                          tst   r18
000467 f409                          brne store_ok
000468 2f24                          mov   r18, r20
                                 store_ok:
000469 9320 0149                     sts   apple_pos, r18
                                 
00046b 912f                          pop   r18
00046c 913f                          pop   r19
00046d 914f                          pop   r20
00046e 915f                          pop   r21
00046f 916f                          pop   r22
000470 917f                          pop   r23
000471 918f                          pop   r24
000472 919f                          pop   r25
000473 91af                          pop   r26
000474 9508                          ret
                                 
                                 ;=====================================================================
                                 ;  snake_draw  render snake & apple
                                 ;=====================================================================
                                 snake_draw:
000475 2722                          clr a0
000476 2733                          clr a1
000477 2744                          clr a2
000478 ddec                          rcall matrix_solid
                                 
000479 9170 0146                     lds  r23, tail_idx
00047b 90e0 0147                     lds  s, snake_len
00047d e060                          ldi  r22, 0
                                 draw_loop:
00047e 156e                          cp   r22, s
00047f f121                          breq draw_done
000480 2f87                          mov  r24, r23
000481 0f86                          add  r24, r22
000482 3480                          cpi  r24, GRID_CELLS
000483 f008                          brlo idx_ok3
000484 5480                          subi r24, GRID_CELLS
                                 idx_ok3:
000485 e0e5                          ldi  ZL, low(snake_body)
000486 e0f1                          ldi  ZH, high(snake_body)
000487 0fe8                          add  ZL, r24
000488 f408                          brcc buf_ok3
000489 95f3                          inc  ZH
                                 buf_ok3:
00048a 8100                          ld   w, Z
00048b 2f80                          mov  r24, w
00048c 7087                          andi r24, COORD_MASK
00048d 2f90                          mov  r25, w
00048e 9596                          lsr  r25
00048f 9596                          lsr  r25
000490 9596                          lsr  r25
000491 7097                          andi r25, COORD_MASK
000492 dd87                          rcall ws_idx_xy
000493 dd8c                          rcall ws_offset_idx
000494 2d1e                          mov  _w, s
000495 951a                          dec  _w
000496 1761                          cp   r22, _w
000497 f021                          breq head_pix
                                 body_pix:
000498 e02f                          ldi  a0, BODY_GREEN
000499 2733                          clr  a1
00049a 2744                          clr  a2
00049b c003                          rjmp store_px
                                 head_pix:
00049c 2722                          clr  a0
00049d 2733                          clr  a1
00049e e04f                          ldi  a2, HEAD_BLUE
                                 store_px:
00049f 9321                          st   Z+, a0
0004a0 9331                          st   Z+, a1
0004a1 8340                          st   Z , a2
0004a2 9563                          inc  r22
0004a3 cfda                          rjmp draw_loop
                                 
                                 draw_done:
                                     ; apple
0004a4 9100 0149                     lds  w, apple_pos
0004a6 3f0f                          cpi  w, EMPTY_CELL
0004a7 f079                          breq flush_frame
0004a8 2f80                          mov  r24, w
0004a9 7087                          andi r24, COORD_MASK
0004aa 2f90                          mov  r25, w
0004ab 9596                          lsr  r25
0004ac 9596                          lsr  r25
0004ad 9596                          lsr  r25
0004ae 7097                          andi r25, COORD_MASK
0004af dd6a                          rcall ws_idx_xy
0004b0 dd6f                          rcall ws_offset_idx
0004b1 2722                          clr  a0
0004b2 e03f                          ldi  a1, APPLE_RED
0004b3 2744                          clr  a2
0004b4 9321                          st   Z+, a0
0004b5 9331                          st   Z+, a1
0004b6 8340                          st   Z , a2
                                 
                                 flush_frame:
0004b7 e0e0                          ldi  ZL, low(WS_BUF_BASE)
0004b8 e0f4                          ldi  ZH, high(WS_BUF_BASE)
0004b9 e400
0004ba 2e00                          _LDI r0, GRID_CELLS
                                 flush_loop:
0004bb 9121                          ld   a0, Z+
0004bc 9131                          ld   a1, Z+
0004bd 9141                          ld   a2, Z+
0004be 94f8                          cli
0004bf dd1b                          rcall ws_byte3wr
0004c0 9478                          sei
0004c1 940a                          dec  r0
0004c2 f7c1                          brne flush_loop
0004c3 dd4c                          rcall ws_reset
                                             .include "game2_state.asm"
0004c4 9508                      
                                 ;  GAME 2  state
                                 ;----------------------------------------------------------------------
                                 
                                 gameTwoInit:
0004c5 db6f                              rcall   lcd_clear
0004c6 e209
0004c7 2e40
0004c8 e000
0004c9 2e50
0004ca db9c                              PRINTF  LCD
0004cb 4147
0004cc 454d
0004cd 3220
0004ce 0000                              .db     "GAME 2",0,0
                                 
                                         ; blue matrix
0004cf e020                              ldi     a0, 0x00
0004d0 e030                              ldi     a1, 0x00
0004d1 e04f                              ldi     a2, 0x0F
0004d2 dd92                              rcall   matrix_solid
                                 
                                 game2_wait:
0004d3 2ce6                              mov     s, sel
0004d4 e002
0004d5 16e0                              _CPI     s, ST_GAME2
0004d6 f4a1                              brne    game2_done
0004d7 e302
0004d8 2e30
0004d9 e001
0004da 930f
0004db 923f
0004dc e300
0004dd 2e30
0004de e006
0004df 943a
0004e0 f7f1
0004e1 943a
0004e2 950a
0004e3 f7d9
0004e4 903f
0004e5 910f
0004e6 943a
0004e7 f791
0004e8 950a
0004e9 f781                              WAIT_MS 50
0004ea cfe8                              rjmp    game2_wait
                                 
                                 game2_done:
                                             .include "game3_state.asm"
0004eb 9508                      
                                 ;  GAME 3  state
                                 ;----------------------------------------------------------------------
                                 
                                 gameThreeInit:
0004ec db48                              rcall   lcd_clear
0004ed e209
0004ee 2e40
0004ef e000
0004f0 2e50
0004f1 db75                              PRINTF  LCD
0004f2 4147
0004f3 454d
0004f4 3320
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm(8): warning: .cseg .db misalignment - padding zero byte
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(85): 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm' included form here
0004f5 0000                              .db     "GAME 3",0
                                 
                                         ; yellow matrix  (R+G)
0004f6 e028                              ldi     a0, 0x08
0004f7 e038                              ldi     a1, 0x08
0004f8 e040                              ldi     a2, 0x00
0004f9 dd6b                              rcall   matrix_solid
                                 
                                 game3_wait:
0004fa 2ce6                              mov     s, sel
0004fb e003
0004fc 16e0                              _CPI     s, ST_GAME3
0004fd f4a1                              brne    game3_done
0004fe e302
0004ff 2e30
000500 e001
000501 930f
000502 923f
000503 e300
000504 2e30
000505 e006
000506 943a
000507 f7f1
000508 943a
000509 950a
00050a f7d9
00050b 903f
00050c 910f
00050d 943a
00050e f791
00050f 950a
000510 f781                              WAIT_MS 50
000511 cfe8                              rjmp    game3_wait
                                 
                                 game3_done:
                                             .include "doctor_state.asm"
000512 9508                      
                                 ;  doctor_state.asm       ST_DOCTOR diagnostic screen (patched)
                                 ;======================================================================
                                 
                                 doctorInit:
000513 932f                              push    r18                    ; save callers a0 slot
                                 
                                         ; 1. clear LCD and show header 
000514 db20                              rcall   lcd_clear
000515 e209
000516 2e40
000517 e000
000518 2e50
000519 db4d                              PRINTF  LCD
00051a 6f44
00051b 7463
00051c 726f
00051d 0000                              .db     "Doctor",0,0
                                 
                                         ; 2. draw red Swiss-cross background on the LED matrix 
00051e d02d                              rcall   matrix_doctor         ; fills buffer & transmits
                                 
                                 ;======================================================================
                                 ;  main refresh loop  runs until sel  ST_DOCTOR
                                 ;======================================================================
                                 doctor_loop:
                                         ;---  temperature housekeeping  ---------------------------------
00051f 9120 0100                         lds     r18, flags
000521 fd20                              sbrc    r18, FLG_TEMP
000522 d12c                              rcall   temp_task
                                 
                                         ;---  fetch last reading & print -------------------------------
000523 9120 0101                         lds     a0, temp_lsb
000525 9130 0102                         lds     a1, temp_msb
000527 db0d                              rcall   lcd_clear
000528 e209
000529 2e40
00052a e000
00052b 2e50
00052c db3a                              PRINTF  LCD
00052d 6f44
00052e 7463
00052f 726f
000530 8b20
000531 0412
000532 4342
000533 0000                              .db     "Doctor ", FFRAC2+FSIGN, a, 4, $42, "C", 0,0
                                 
000534 ef0a
000535 2e30
000536 e001
000537 930f
000538 923f
000539 e300
00053a 2e30
00053b e006
00053c 943a
00053d f7f1
00053e 943a
00053f 950a
000540 f7d9
000541 903f
000542 910f
000543 943a
000544 f791
000545 950a
000546 f781                              WAIT_MS 250                    ; 4 Hz update
                                 
                                         ;---  stay only while we are still in Doctor -------------------
000547 2d26                              mov     r18, sel
000548 3024                              cpi     r18, ST_DOCTOR
000549 f2a9                              breq    doctor_loop
                                 
                                         ; 3. leave state 
00054a 912f                              pop     r18
00054b 9508                              ret
                                 
                                 
                                 ;======================================================================
                                 ;  matrix_doctor   fill 88 buffer red, then blank specified pixels
                                 ;  clobbers: a0a2, r0, r18r22, r24r25, Z, w=r16 (all scratch)
                                 ;======================================================================
                                 matrix_doctor:
00054c 936f                              push    r22
00054d 93ef                              push    ZL
00054e 93ff                              push    ZH
                                 
                                         ;--- set fill colour to red (GRB = 0x00,0x0F,0x00) -------------
00054f e020                              ldi     a0, 0x00            ; G
000550 e03f                              ldi     a1, 0x0F            ; R
000551 e040                              ldi     a2, 0x00            ; B
                                 
                                         ;--- 1) fill frame buffer (64 pixels) --------------------------
000552 e0e0                              ldi     ZL, low(WS_BUF_BASE)
000553 e0f4                              ldi     ZH, high(WS_BUF_BASE)
000554 e460                              ldi     r22, 64
                                 md_fill:
000555 9321                              st      Z+, a0
000556 9331                              st      Z+, a1
000557 9341                              st      Z+, a2
000558 956a                              dec     r22
000559 f7d9                              brne    md_fill
                                 
                                         ;--- 2) blank out holes by writing 0,0,0 at each coord --------
                                         ; list of pixels to turn off:
                                         ; (3,1),(4,1),(3,2),(4,2),(3,3),(4,3),(3,4),(4,4),
                                         ; (3,5),(4,5),(3,6),(4,6),
                                         ; (1,3),(1,4),(2,3),(2,4),(5,3),(5,4),(6,3),(6,4)
                                 
                                         ; helper: a zero color in r1
00055a 2411                              clr     r1
                                 
                                         ; (3,1)
00055b e083                              ldi     r24,3
00055c e091                              ldi     r25,1
00055d dcbc                              rcall   ws_idx_xy
00055e dcc1                              rcall   ws_offset_idx
00055f 9211                              st      Z+, r1
000560 9211                              st      Z+, r1
000561 8210                              st      Z,   r1
                                 
                                         ; (4,1)
000562 e084                              ldi     r24,4
000563 e091                              ldi     r25,1
000564 dcb5                              rcall   ws_idx_xy
000565 dcba                              rcall   ws_offset_idx
000566 9211                              st      Z+, r1
000567 9211                              st      Z+, r1
000568 8210                              st      Z,   r1
                                 
                                         ; (3,2)
000569 e083                              ldi     r24,3
00056a e092                              ldi     r25,2
00056b dcae                              rcall   ws_idx_xy
00056c dcb3                              rcall   ws_offset_idx
00056d 9211                              st      Z+, r1
00056e 9211                              st      Z+, r1
00056f 8210                              st      Z,   r1
                                 
                                         ; (4,2)
000570 e084                              ldi     r24,4
000571 e092                              ldi     r25,2
000572 dca7                              rcall   ws_idx_xy
000573 dcac                              rcall   ws_offset_idx
000574 9211                              st      Z+, r1
000575 9211                              st      Z+, r1
000576 8210                              st      Z,   r1
                                 
                                         ; (3,3)
000577 e083                              ldi     r24,3
000578 e093                              ldi     r25,3
000579 dca0                              rcall   ws_idx_xy
00057a dca5                              rcall   ws_offset_idx
00057b 9211                              st      Z+, r1
00057c 9211                              st      Z+, r1
00057d 8210                              st      Z,   r1
                                 
                                         ; (4,3)
00057e e084                              ldi     r24,4
00057f e093                              ldi     r25,3
000580 dc99                              rcall   ws_idx_xy
000581 dc9e                              rcall   ws_offset_idx
000582 9211                              st      Z+, r1
000583 9211                              st      Z+, r1
000584 8210                              st      Z,   r1
                                 
                                         ; (3,4)
000585 e083                              ldi     r24,3
000586 e094                              ldi     r25,4
000587 dc92                              rcall   ws_idx_xy
000588 dc97                              rcall   ws_offset_idx
000589 9211                              st      Z+, r1
00058a 9211                              st      Z+, r1
00058b 8210                              st      Z,   r1
                                 
                                         ; (4,4)
00058c e084                              ldi     r24,4
00058d e094                              ldi     r25,4
00058e dc8b                              rcall   ws_idx_xy
00058f dc90                              rcall   ws_offset_idx
000590 9211                              st      Z+, r1
000591 9211                              st      Z+, r1
000592 8210                              st      Z,   r1
                                 
                                         ; (3,5)
000593 e083                              ldi     r24,3
000594 e095                              ldi     r25,5
000595 dc84                              rcall   ws_idx_xy
000596 dc89                              rcall   ws_offset_idx
000597 9211                              st      Z+, r1
000598 9211                              st      Z+, r1
000599 8210                              st      Z,   r1
                                 
                                         ; (4,5)
00059a e084                              ldi     r24,4
00059b e095                              ldi     r25,5
00059c dc7d                              rcall   ws_idx_xy
00059d dc82                              rcall   ws_offset_idx
00059e 9211                              st      Z+, r1
00059f 9211                              st      Z+, r1
0005a0 8210                              st      Z,   r1
                                 
                                         ; (3,6)
0005a1 e083                              ldi     r24,3
0005a2 e096                              ldi     r25,6
0005a3 dc76                              rcall   ws_idx_xy
0005a4 dc7b                              rcall   ws_offset_idx
0005a5 9211                              st      Z+, r1
0005a6 9211                              st      Z+, r1
0005a7 8210                              st      Z,   r1
                                 
                                         ; (4,6)
0005a8 e084                              ldi     r24,4
0005a9 e096                              ldi     r25,6
0005aa dc6f                              rcall   ws_idx_xy
0005ab dc74                              rcall   ws_offset_idx
0005ac 9211                              st      Z+, r1
0005ad 9211                              st      Z+, r1
0005ae 8210                              st      Z,   r1
                                 
                                         ; (1,3)
0005af e081                              ldi     r24,1
0005b0 e093                              ldi     r25,3
0005b1 dc68                              rcall   ws_idx_xy
0005b2 dc6d                              rcall   ws_offset_idx
0005b3 9211                              st      Z+, r1
0005b4 9211                              st      Z+, r1
0005b5 8210                              st      Z,   r1
                                 
                                         ; (1,4)
0005b6 e081                              ldi     r24,1
0005b7 e094                              ldi     r25,4
0005b8 dc61                              rcall   ws_idx_xy
0005b9 dc66                              rcall   ws_offset_idx
0005ba 9211                              st      Z+, r1
0005bb 9211                              st      Z+, r1
0005bc 8210                              st      Z,   r1
                                 
                                         ; (2,3)
0005bd e082                              ldi     r24,2
0005be e093                              ldi     r25,3
0005bf dc5a                              rcall   ws_idx_xy
0005c0 dc5f                              rcall   ws_offset_idx
0005c1 9211                              st      Z+, r1
0005c2 9211                              st      Z+, r1
0005c3 8210                              st      Z,   r1
                                 
                                         ; (2,4)
0005c4 e082                              ldi     r24,2
0005c5 e094                              ldi     r25,4
0005c6 dc53                              rcall   ws_idx_xy
0005c7 dc58                              rcall   ws_offset_idx
0005c8 9211                              st      Z+, r1
0005c9 9211                              st      Z+, r1
0005ca 8210                              st      Z,   r1
                                 
                                         ; (5,3)
0005cb e085                              ldi     r24,5
0005cc e093                              ldi     r25,3
0005cd dc4c                              rcall   ws_idx_xy
0005ce dc51                              rcall   ws_offset_idx
0005cf 9211                              st      Z+, r1
0005d0 9211                              st      Z+, r1
0005d1 8210                              st      Z,   r1
                                 
                                         ; (5,4)
0005d2 e085                              ldi     r24,5
0005d3 e094                              ldi     r25,4
0005d4 dc45                              rcall   ws_idx_xy
0005d5 dc4a                              rcall   ws_offset_idx
0005d6 9211                              st      Z+, r1
0005d7 9211                              st      Z+, r1
0005d8 8210                              st      Z,   r1
                                 
                                         ; (6,3)
0005d9 e086                              ldi     r24,6
0005da e093                              ldi     r25,3
0005db dc3e                              rcall   ws_idx_xy
0005dc dc43                              rcall   ws_offset_idx
0005dd 9211                              st      Z+, r1
0005de 9211                              st      Z+, r1
0005df 8210                              st      Z,   r1
                                 
                                         ; (6,4)
0005e0 e086                              ldi     r24,6
0005e1 e094                              ldi     r25,4
0005e2 dc37                              rcall   ws_idx_xy
0005e3 dc3c                              rcall   ws_offset_idx
0005e4 9211                              st      Z+, r1
0005e5 9211                              st      Z+, r1
0005e6 8210                              st      Z,   r1
                                 
                                         ;--- 3) transmit the frame to the LEDs ------------------------
0005e7 e0e0                              ldi     ZL, low(WS_BUF_BASE)
0005e8 e0f4                              ldi     ZH, high(WS_BUF_BASE)
0005e9 e400
0005ea 2e00                              _LDI    r0, 64
                                 md_send:
0005eb 9121                              ld      a0, Z+
0005ec 9131                              ld      a1, Z+
0005ed 9141                              ld      a2, Z+
0005ee 94f8                              cli
0005ef dbeb                              rcall   ws_byte3wr
0005f0 9478                              sei
0005f1 940a                              dec     r0
0005f2 f7c1                              brne    md_send
0005f3 dc1c                              rcall   ws_reset
                                 
0005f4 91ff                              pop     ZH
0005f5 91ef                              pop     ZL
0005f6 916f                              pop     r22
0005f7 9508                      
                                 ;======================================================================
                                 ;  RESET sequence
                                 ;======================================================================
                                 reset:
0005f8 ef0f
0005f9 bf0d
0005fa e100
0005fb bf0e                                  LDSP  RAMEND
0005fc da4c                                  rcall LCD_init
0005fd db84                                  rcall wire1_init
0005fe dc2b                                  rcall encoder_init
                                 
                                 ;  Buttons PD0PD3: inputs with pull-ups ----------------------------
0005ff 9888                                  cbi   DDRD,0
000600 9889                                  cbi   DDRD,1
000601 988a                                  cbi   DDRD,2
000602 988b                                  cbi   DDRD,3
000603 9a90                                  sbi   PORTD,0
000604 9a91                                  sbi   PORTD,1
000605 9a92                                  sbi   PORTD,2
000606 9a93                                  sbi   PORTD,3
                                 
                                 ;  WS2812 driver init (sets PD7 output) -----------------------------
000607 dbd0                                  rcall ws_init
                                 
                                 ;  Heartbeat LED on PF7 (active-low) --------------------------------
000608 e800
000609 9300 0061                             OUTEI DDRF,(1<<LED_BIT)    ; PF7 ? output (clobbers w)
00060b e800
00060c 9300 0062                             OUTEI PORTF,(1<<LED_BIT)   ; drive high = LED off
                                 
                                 
                                 
                                 ;  Ensure WS2812 line idle low until driver starts ------------------
00060e 9897                                  cbi   PORTD,7
                                 
                                 ;  Timer-1 one-second tick ------------------------------------------
00060f ef00                                  ldi   w,T1_PREH
000610 bd0d                                  out   TCNT1H,w
000611 eb0e                                  ldi   w,T1_PREL
000612 bd0c                                  out   TCNT1L,w
000613 e005                                  ldi   w,(1<<CS12)|(1<<CS10)
000614 bd0e                                  out   TCCR1B,w
000615 e004
000616 bf07                                  OUTI  TIMSK,(1<<TOIE1)
                                 
                                 ;  INT0INT3 falling-edge config -----------------------------------
000617 ea0a
000618 9300 006a                             OUTEI EICRA,0b10101010
00061a e00f
00061b bf09                                  OUTI  EIMSK,0b00001111
                                 
00061c 9478                                  sei                         ; global IRQ enable
                                 
                                 ;  Kick off first DS18B20 conversion --------------------------------
00061d 2700                                  clr   w                     ; w is volatile  fine here
00061e 9300 0103                             sts   phase,w
000620 d018                                  rcall temp_convert
                                 
000621 2466                                  clr   sel                   ; start in Home state
                                 
                                 ;======================================================================
                                 ;  MAIN LOOP  state dispatch
                                 ;======================================================================
                                 main_loop:
                                 switch:
000622 2ce6                                  mov   s,sel                ; copy once, keep stable
000623 e000
000624 16e0                                  _CPI   s,ST_HOME
000625 f411                                  brne  swSnake
000626 dc5a                                  rcall home_init
000627 cffa                                  rjmp  switch
                                 
                                 swSnake:
000628 e001
000629 16e0                                  _CPI   s,ST_GAME1
00062a f411                                  brne  swGameTwo
00062b dcf9                                  rcall snake_game_init; changed nameeeee
00062c cff5                                  rjmp  switch
                                 
                                 swGameTwo:
00062d e002
00062e 16e0                                  _CPI   s,ST_GAME2
00062f f411                                  brne  swGameThree
000630 de94                                  rcall gameTwoInit
000631 cff0                                  rjmp  switch
                                 
                                 swGameThree:
000632 e003
000633 16e0                                  _CPI   s,ST_GAME3
000634 f411                                  brne  swDoctor
000635 deb6                                  rcall gameThreeInit
000636 cfeb                                  rjmp  switch
                                 
                                 swDoctor:
000637 dedb                                  rcall doctorInit
000638 cfe9                                  rjmp  switch
                                 
                                 ;======================================================================
                                 ;  1-Wire helpers
                                 ;======================================================================
                                 ; Use s (r14) instead of w so we dont depend on the volatile macro reg.
                                 
                                 temp_convert:
000639 92ef                                  push  s
00063a db4a                                  rcall wire1_reset
00063b ec2c                                  ldi   a0,skipROM
00063c db7c                                  rcall wire1_write
00063d e424                                  ldi   a0,convertT
00063e db7a                                  rcall wire1_write
00063f 90ef                                  pop   s
000640 9508                                  ret
                                 
                                 temp_fetch:
000641 92ef                                  push  s
000642 db42                                  rcall wire1_reset
000643 ec2c                                  ldi   a0,skipROM
000644 db74                                  rcall wire1_write
000645 eb2e                                  ldi   a0,readScratchpad
000646 db72                                  rcall wire1_write
000647 db7c                                  rcall wire1_read
000648 9320 0101                             sts   temp_lsb,a0
00064a db79                                  rcall wire1_read
00064b 9320 0102                             sts   temp_msb,a0
00064d 90ef                                  pop   s
00064e 9508                                  ret
                                 
                                 ;---------------------------------------------------------------------
                                 ;  Background temperature task
                                 ;---------------------------------------------------------------------
                                 ; Only s is used; w may change at macro calls we dont care about here.
                                 
                                 temp_task:
00064f 90e0 0100                             lds   s,flags
000651 ef0e
000652 22e0                                  _ANDI  s,~(1<<FLG_TEMP)
000653 92e0 0100                             sts   flags,s
                                 
000655 90e0 0103                             lds   s,phase
000657 20ee                                  tst   s
000658 f029                                  breq  temp_do_convert
                                 
000659 dfe7                                  rcall temp_fetch
00065a 24ee                                  clr   s
00065b 92e0 0103                             sts   phase,s
00065d 9508                                  ret
                                 
                                 temp_do_convert:
00065e dfda                                  rcall temp_convert
00065f e001
000660 2ee0                                  _LDI   s,1
000661 92e0 0103                             sts   phase,s
000663 9508                                  ret
                                 
                                 ;======================================================================
                                 ;  Interrupt service routines
                                 ;======================================================================
                                 ;----------------------  INT0  next state  ---------------------------
                                 int0_isr:
000664 930f                                  push  w                    ; save volatile macro reg
000665 9463                                  inc   sel
000666 e004                                  ldi   w,REG_STATES
000667 1660                                  cp    sel,w
000668 f008                                  brlo  int0_done
000669 2466                                  clr   sel                  ; wrap ? 0
                                 int0_done:
00066a 910f                                  pop   w
00066b 9518                                  reti
                                 
                                 ;----------------------  INT1  previous state ------------------------
                                 int1_isr:
00066c 930f                                  push  w
00066d 2066                                  tst   sel
00066e f421                                  brne  int1_dec
00066f e003                                  ldi   w,REG_STATES-1       ; wrap ? 3
000670 2e60                                  mov   sel,w
000671 910f                                  pop   w
000672 9518                                  reti
                                 int1_dec:
000673 946a                                  dec   sel
000674 910f                                  pop   w
000675 9518                                  reti
                                 
                                 ;----------------------  INT2  goto Home ----------------------------
                                 int2_isr:
000676 2466                                  clr   sel
000677 9518                                  reti
                                 
                                 ;----------------------  INT3  Doctor mode --------------------------
                                 int3_isr:
000678 930f                                  push  w
000679 e004                                  ldi   w,ST_DOCTOR
00067a 2e60                                  mov   sel,w
00067b 910f                                  pop   w
00067c 9518                                  reti
                                 
                                 ;----------------------  Timer-1 overflow ----------------------------
                                 t1_isr:
00067d 930f                                  push  w                     ; save macro scratch
00067e 931f                                  push  _w                    ; save ISR scratch
                                 
                                             ; reload counter
00067f ef00                                  ldi   w,T1_PREH
000680 bd0d                                  out   TCNT1H,w
000681 eb0e                                  ldi   w,T1_PREL
000682 bd0c                                  out   TCNT1L,w
                                 
                                             ; heartbeat LED on PF7 (toggle)
000683 90e0 0062                             lds   s,PORTF
000685 e810                                  ldi   _w,(1<<LED_BIT)
000686 26e1                                  eor   s,_w
000687 92e0 0062                             sts   PORTF,s
                                 
                                             ; set temperature task flag
000689 90e0 0100                             lds   s,flags
00068b e001
00068c 2ae0                                  _ORI   s,(1<<FLG_TEMP)
00068d 92e0 0100                             sts   flags,s
                                 
00068f 911f                                  pop   _w
000690 910f                                  pop   w
000691 9518                                  reti
                                 ;======================================================================
                                 ;TODO: increse the debounce time for the buttons 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  : 139 r0 :  15 r1 : 103 r2 :   5 r3 :  57 r4 :   8 
r5 :   8 r6 :  16 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:  35 r15:   2 r16: 299 r17:  30 r18:  83 r19:  64 r20:  70 
r21:  39 r22:  61 r23:  43 r24:  77 r25:  72 r26:   8 r27:   4 r28:   0 
r29:   0 r30:  40 r31:  35 
Registers used: 30 out of 35 (85.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :  16 adiw  :   5 and   :   1 
andi  :  20 asr   :   2 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :   9 brcs  :   0 break :   0 breq  :  35 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   7 brlt  :   0 brmi  :   2 
brne  :  62 brpl  :   1 brsh  :   1 brtc  :   5 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   6 call  :   0 cbi   :  15 cbr   :   0 
clc   :   1 clh   :   0 cli   :   8 cln   :   0 clr   :  38 cls   :   0 
clt   :   2 clv   :   0 clz   :   3 com   :   8 cp    :  20 cpc   :   3 
cpi   :  24 cpse  :   0 dec   :  55 elpm  :   0 eor   :   4 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :  11 inc   :  23 
jmp   :   6 ld    :  22 ldd   :   0 ldi   : 261 lds   :  28 lpm   :  12 
lsl   :  14 lsr   :  15 mov   :  83 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :  18 or    :   1 ori   :   3 out   :  16 
pop   :  72 push  :  70 rcall : 166 ret   :  52 reti  :   6 rjmp  :  68 
rol   :  10 ror   :  17 sbc   :   3 sbci  :   0 sbi   :  14 sbic  :   0 
sbis  :   0 sbiw  :   1 sbr   :   1 sbrc  :  21 sbrs  :   4 sec   :   0 
seh   :   0 sei   :   9 sen   :   0 ser   :   0 ses   :   0 set   :   2 
sev   :   0 sez   :   1 sleep :   0 spm   :   0 st    : 123 std   :   0 
sts   :  31 sub   :   4 subi  :  10 swap  :   4 tst   :  17 wdr   :   0 

Instructions used: 67 out of 114 (58.8%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000d24   3268     60   3328  131072   2.5%
[.dseg] 0x000100 0x000154      0     84     84    4096   2.1%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 2 warnings
