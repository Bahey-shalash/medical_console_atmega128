
AVRASM ver. 2.2.6  Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm Wed May 21 20:07:17 2025

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(10): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\definitions.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(11): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\macros.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(56): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\lcd.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(57): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\printf.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(58): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\wire1.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(59): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_driver.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(60): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\encoder.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(61): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_helpers.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(65): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\home_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(66): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(67): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(68): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(69): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(10): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\definitions.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(11): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\macros.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(56): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\lcd.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(57): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\printf.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(58): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\wire1.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(59): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_driver.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(60): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\encoder.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(61): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\ws2812_helpers.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(65): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\home_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(66): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(67): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(68): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm'
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(69): Including file 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm'
                                 
                                 ;======================================================================
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;  main.asm   ATmega128L @ 4 MHz  STK-300
                                 ;  Modular finite-state machine
                                 ;    WS2812 matrix on PD7  (driver)
                                 ;    LED-strip heartbeat on PF7 (active-low)
                                 ;    Buttons on PD0PD3 (INT0INT3)
                                 ;======================================================================
                                 
                                             .include "m128def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                             .include "definitions.asm"
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                             .include "macros.asm"
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 ;----------------------------------------------------------------------
                                 ;  Global registers / constants
                                 ;----------------------------------------------------------------------
                                             .def  sel        = r6         ; current state
                                             .equ  FLG_TEMP   = 0
                                             .equ  REG_STATES = 4          ; 03 = HomeGame3
                                             .equ  ST_HOME    = 0
                                             .equ  ST_GAME1   = 1
                                             .equ  ST_GAME2   = 2
                                             .equ  ST_GAME3   = 3
                                             .equ  ST_DOCTOR  = 4
                                 
                                             .equ  T1_PREH    = 0xF0       ; Timer-1 preload (high)
                                             .equ  T1_PREL    = 0xBE       ; Timer-1 preload (low)
                                             .equ  LED_BIT    = 7          ; PF7 heartbeat
                                 
                                 ;----------------------------------------------------------------------
                                 .dseg
000100                           flags:      .byte 1                     ; bit 0 = FLG_TEMP
000101                           temp_lsb:   .byte 1
000102                           temp_msb:   .byte 1
000103                           phase:      .byte 1                     ; 0=Convert, 1=Read
                                 ;----------------------------------------------------------------------
                                 .cseg
                                 ;======================================================================
                                 ;  Interrupt vectors
                                 ;======================================================================
                                             .org 0
000000 940c 045e                             jmp  reset
                                             .org INT0addr
000002 940c 04c8                             jmp  int0_isr
                                             .org INT1addr
000004 940c 04d0                             jmp  int1_isr
                                             .org INT2addr
000006 940c 04da                             jmp  int2_isr
                                             .org INT3addr
000008 940c 04dc                             jmp  int3_isr
                                             .org OVF1addr
00001c 940c 04e1                             jmp  t1_isr
                                 
                                 ;----------------------------------------------------------------------
                                 ;  Library / driver includes (after vectors)
                                 ;----------------------------------------------------------------------
                                             .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00001e 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
000020 fc37
000021 cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
000022 d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000023 9300 8000                 	sts	LCD_IR, w		; store w in IR
000025 9508                      	ret
                                 	
                                 lcd_4us:
000026 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000027 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000028 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000029 302d
00002a f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
00002b 302a
00002c f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
00002d 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
00002f fd07
000030 cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
000031 dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
000032 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000034 9508                      	ret	
                                 	
000035 e001
000036 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
000037 e002
000038 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000039 e100
00003a cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
00003b e104
00003c cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
00003d e108
00003e cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
00003f e10c
000040 cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
000041 e00d
000042 cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
000043 e00c
000044 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000045 e00e
000046 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000047 e00c
000048 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000049 b705                      	in	w,MCUCR					; enable access to ext. SRAM
00004a 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
00004b bf05                      	out	MCUCR,w
00004c e001
00004d dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
00004e e006
00004f dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
000050 e00c
000051 dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
000052 e308
000053 dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000054 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
000055 2f02                      	mov	w,a0
000056 6800                      	ori	w,0b10000000
000057 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000058 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
00005a fd07
00005b cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
00005c 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
00005d 6800                      	ori	w,0b10000000		; write address command
00005e dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
00005f 9300 8000                 	sts	LCD_IR,w			; store in IR
000061 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
000062 932f                      	push	a0				; safeguard a0
000063 e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
000064 dff0                      	rcall	LCD_pos			; set cursor position
000065 912f                      	pop	a0					; restore a0
                                             .include "printf.asm"
000066 9508                      
                                 ; purpose library, formatted output generation
                                 ; v2019.02 20180821 supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000067 91ff
000068 91ef                      	POPZ			; z points to begin of "string"
000069 0fee
00006a 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
00006b 93af
00006c 93bf                      	PUSHX
                                 		
                                 _printf_read:
00006d 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00006e 9631                      	adiw	zl,1	; increment pointer Z
00006f 2000                      	tst	r0			; test for ZERO (=end of string)
000070 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
000071 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
000072 2d00                      	mov	w,r0
000073 d017                      	rcall	_putw	; display the character
000074 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000075 9631                      	adiw	zl,1	; point to the next character
000076 95f6
000077 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000078 91bf
000079 91af                      	POPX
00007a 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
00007b fa00                      	bst	r0,0		; store sign in T
00007c 2d00                      	mov	w,r0		; store formatting character in w
00007d 95c8                      	lpm	
00007e 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00007f 36a0                      	cpi	xl,0x60
000080 f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
000081 e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
000082 c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
000083 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000084 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000085 3804
000086 f079                      	JK	w,FCHAR,_putchar
000087 3805
000088 f081                      	JK	w,FSTR ,_putstr
000089 c015                      	rjmp	_putnum
                                 	
00008a cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
00008b 932f
00008c 93ff
00008d 93ef                      	PUSH3	a0,zh,zl
00008e 2de4
00008f 2df5
000090 2f20                      	MOV3	a0,zh,zl, w,e1,e0
000091 9509                      	icall			; indirect call to "putc"
000092 91ef
000093 91ff
000094 912f                      	POP3	a0,zh,zl
000095 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000096 910c                      	ld	w,x
000097 dff3                      	rcall	_putw
000098 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000099 910d                      	ld	w,x+
00009a 2300                      	tst	w
00009b f409                      	brne	PC+2
00009c cfd0                      	rjmp	_printf_read
00009d dfed                      	rcall	_putw
00009e cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00009f 935f
0000a0 934f
0000a1 933f
0000a2 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
0000a3 939f
0000a4 938f
0000a5 937f
0000a6 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
0000a7 912d
0000a8 913d
0000a9 914d
0000aa 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
0000ab fd06
0000ac c006                      	JB1	w,6,_putdec
0000ad fd05
0000ae c00f                      	JB1	w,5,_putbin
0000af fd04
0000b0 c010                      	JB1	w,4,_puthex
0000b1 fd03
0000b2 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0000b3 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0000b4 2f70                      	mov	b1,w
0000b5 9576                      	lsr	b1
0000b6 7077                      	andi	b1,0b111	
0000b7 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000b8 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0000b9 2f90                      	mov	b3,w
0000ba 9592                      	swap	b3
0000bb 7093                      	andi	b3,0b11
0000bc 9593                      	inc	b3			; b3 = number of bytes (1..4)
0000bd c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0000be e062                      	ldi	b0,2		; b0 = base (2)
0000bf e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0000c0 c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0000c1 e160                      	ldi	b0,16		; b0 = base (16)
0000c2 e094                      	ldi	b3,4		; b3 = number of bytes (4)
0000c3 c000                      	rjmp	_getdig
                                 
                                 _getdig:
0000c4 2f70                      	mov	b1,w
0000c5 9576                      	lsr	b1
0000c6 7077                      	andi	b1,0b111
0000c7 f409                      	brne	PC+2
0000c8 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0000c9 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0000ca e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0000cb c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0000cc e06a                      	ldi	b0,10		; base=10	
0000cd 95c8                      	lpm
0000ce 2d80                      	mov	b2,r0		; load dec.point position
0000cf 9631                      	adiw	zl,1	; increment char pointer
0000d0 95c8                      	lpm
0000d1 2d70                      	mov	b1,r0		; load ii.ff format
0000d2 9631                      	adiw	zl,1	; increment char pointer
                                 	
0000d3 2f90                      	mov	b3,w
0000d4 9595                      	asr	b3
0000d5 7093                      	andi	b3,0b11
0000d6 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0000d7 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0000d8 3094
0000d9 f081                      	JK	b3,4,_printf_4b
0000da 3093
0000db f051                      	JK	b3,3,_printf_3b
0000dc 3092
0000dd f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0000de 2733                      	clr	a1
0000df f416                      	brtc	PC+3	; T=1 sign extension
0000e0 fd27                      	sbrc	a0,7
0000e1 ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0000e2 2744                      	clr	a2
0000e3 f416                      	brtc	PC+3	; T=1 sign extension	
0000e4 fd37                      	sbrc	a1,7
0000e5 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0000e6 2755                      	clr	a3
0000e7 f416                      	brtc	PC+3	; T=1 sign extension
0000e8 fd47                      	sbrc	a2,7
0000e9 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0000ea d009                      	rcall	_ftoa		; float to ascii
0000eb 916f
0000ec 917f
0000ed 918f
0000ee 919f                      	POP4	b3,b2,b1,b0	; restore b
0000ef 912f
0000f0 913f
0000f1 914f
0000f2 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0000f3 cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0000f4 92cf                      	push	d0
0000f5 92bf
0000f6 92af
0000f7 929f
0000f8 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0000f9 18bb
0000fa 24aa
0000fb 2499
0000fc 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0000fd f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0000fe 94e8                      	clt
0000ff 2355                      	tst	a3				; if MSb(a)=1 then a=-a
000100 f46a                      	brpl	_ftoa_plus
000101 9468                      	set					; T=1 (minus)
000102 2377                      	tst	b1
000103 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000104 5170                      	subi	b1,0x10		; decrease int digits
000105 9550
000106 9540
000107 9530
000108 9520
000109 ef0f
00010a 1b20
00010b 0b30
00010c 0b40
00010d 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
00010e 2388                      	tst	b2				; b0=0 (only integer part)
00010f f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
000110 9555
000111 9547
000112 9537
000113 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000114 94b7
000115 94a7
000116 9497
000117 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000118 958a
000119 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
00011a 937f                      	push	b1			; ii.ff (ii=int digits)
00011b 9572                      	swap	b1
00011c 707f                      	andi	b1,0x0f
                                 	
00011d e20e                      	ldi	w,'.'			; push decimal point
00011e 930f                      	push	w
                                 _ftoa_int1:
00011f d045                      	rcall	_div41		; int=int/10
000120 2d0c                      	mov	w,d0			; d=reminder
000121 d030                      	rcall	_hex2asc
000122 930f                      	push	w			; push rem(int/10)
000123 2700
000124 1720
000125 0730
000126 0740
000127 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000128 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000129 2377                      	tst	b1
00012a f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
00012b 957a
00012c f791                      	DJNZ	b1,_ftoa_int1
00012d c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00012e 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00012f f029                      	breq	_ftoa_sign
000130 957a                      	dec	b1
000131 f019                      	breq	_ftoa_sign
000132 e200                      	ldi	w,' '			; write spaces
000133 df57                      	rcall	_putw	
000134 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000135 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000136 e20d                      	ldi	w,'-'
000137 df53                      	rcall	_putw
                                 _ftoa_int3:
000138 910f                      	pop	w
000139 320e                      	cpi	w,'.'
00013a f011                      	breq	PC+3
00013b df4f                      	rcall	_putw
00013c cffb                      	rjmp	_ftoa_int3
                                 
00013d 917f                      	pop	b1				; ii.ff (ff=frac digits)
00013e 707f                      	andi	b1,0x0f
00013f 2377                      	tst	b1
000140 f059                      	breq	_ftoa_end
                                 _ftoa_point:	
000141 df49                      	rcall	_putw		; write decimal point
000142 2d28
000143 2d39
000144 2d4a
000145 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000146 d011                      	rcall	_mul41		; d.frac=10*frac
000147 2d0c                      	mov	w,d0
000148 d009                      	rcall	_hex2asc
000149 df41                      	rcall	_putw
00014a 957a
00014b f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
00014c 908f
00014d 909f
00014e 90af
00014f 90bf                      	POP4	c3,c2,c1,c0
000150 90cf                      	pop	d0
000151 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
000152 300a                      	cpi	w,10
000153 f410                      	brsh	PC+3
000154 5d00                      	addi	w,'0'
000155 9508                      	ret
000156 5a09                      	addi	w,('a'-10)
000157 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000158 24cc                      _mul41:	clr	d0			; clear byte4 of result
000159 e200                      	ldi	w,32			; load bit counter
00015a 9488                      __m41:	clc				; clear carry
00015b fd20                      	sbrc	a0,0		; skip addition if LSB=0
00015c 0ec6                      	add	d0,b0			; add b to MSB of a
00015d 94c7
00015e 9557
00015f 9547
000160 9537
000161 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
000162 950a
000163 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000164 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000165 24cc                      _div41:	clr	d0			; d will contain the remainder
000166 e200                      	ldi	w,32			; load bit counter
000167 1f22
000168 1f33
000169 1f44
00016a 1f55
00016b 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
00016c 1ac6                      	sub	d0, b0			; subtract b from remainder
00016d f408                      	brcc	PC+2	
00016e 0ec6                      	add	d0, b0			; restore if remainder became negative
00016f 950a
000170 f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
000171 1f22
000172 1f33
000173 1f44
000174 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000175 9550
000176 9540
000177 9530
000178 9520                      	COM4	a3,a2,a1,a0	; complement result
000179 9508                      	ret
                                             .include "wire1.asm"
                                 
                                 ; purpose Dallas 1-wire(R) interface library
                                 
                                 ; === definitions ===
                                 .equ	DQ_port	= PORTB
                                 .equ	DQ_pin	= DQ
                                 
                                 .equ	DS18B20		= 0x28
                                 
                                 .equ	readROM		= 0x33
                                 .equ	matchROM	= 0x55
                                 .equ	skipROM		= 0xcc
                                 .equ	searchROM	= 0xf0
                                 .equ	alarmSearch	= 0xec
                                 
                                 .equ	writeScratchpad	= 0x4e
                                 .equ	readScratchpad	= 0xbe
                                 .equ	copyScratchpad	= 0x48
                                 .equ	convertT	= 0x44
                                 .equ	recallE2	= 0xb8
                                 .equ	readPowerSupply	= 0xb4
                                 
                                 ; === routines ===
                                 
                                 .macro	WIRE1	; t0,t1,t2
                                 	sbi	DQ_port-1,DQ_pin	; pull DQ low (DDR=1 output)
                                 	ldi	w,(@0+1)/2	
                                 	rcall	wire1_wait		; wait low time (t0)
                                 	cbi	DQ_port-1,DQ_pin	; release DQ (DDR=0 input)
                                 	ldi	w,(@1+1)/2	
                                 	rcall	wire1_wait		; wait high time (t1)
                                 	in	w,DQ_port-2			; sample line (PINx=PORTx-2)
                                 	bst	w,DQ_pin			; store result in T
                                 	ldi	w,(@2+1)/2	
                                 	rcall	wire1_wait		; wait separation time (t2)
                                 	ret
                                 	.endmacro	
                                 
                                 wire1_wait:
00017a 950a                      	dec	w					; loop time 2usec
00017b 0000                      	nop
00017c 0000                      	nop
00017d 0000                      	nop
00017e 0000                      	nop
00017f 0000                      	nop
000180 f7c9                      	brne	wire1_wait
000181 9508                      	ret
                                 
                                 wire1_init:
000182 98c5                      	cbi	DQ_port,  DQ_pin	; PORT=0 low (for pull-down)
000183 98bd                      	cbi	DQ_port-1,DQ_pin	; DDR=0 (input hi Z)
000184 9508                      	ret
                                 	
000185 9abd
000186 ef00
000187 dff2
000188 98bd
000189 e203
00018a dfef
00018b b306
00018c fb05
00018d ec0d
00018e dfeb
00018f 9508                      wire1_reset:	WIRE1	480,70,410
000190 9abd
000191 e10c
000192 dfe7
000193 98bd
000194 e002
000195 dfe4
000196 b306
000197 fb05
000198 e001
000199 dfe0
00019a 9508                      wire1_write0:	WIRE1	56,4,1
00019b 9abd
00019c e001
00019d dfdc
00019e 98bd
00019f e10e
0001a0 dfd9
0001a1 b306
0001a2 fb05
0001a3 e001
0001a4 dfd5
0001a5 9508                      wire1_write1:	WIRE1	1,59,1
0001a6 9abd
0001a7 e001
0001a8 dfd1
0001a9 98bd
0001aa e007
0001ab dfce
0001ac b306
0001ad fb05
0001ae e107
0001af dfca
0001b0 9508                      wire1_read1:	WIRE1	1,14,45
                                 	
                                 wire1_write:
0001b1 933f                      	push	a1
0001b2 e038                      	ldi	a1,8
0001b3 9527                      	ror	a0
                                 
0001b4 f410                      	brcc	PC+3				; if C=1 then wire1, else wire0
0001b5 dfe5                      	rcall	wire1_write1
0001b6 c001                      	rjmp	PC+2
0001b7 dfd8                      	rcall	wire1_write0
                                 
0001b8 953a
0001b9 f7c9                      	DJNZ	a1,wire1_write+2	; dec and jump if not zero
0001ba 913f                      	pop	a1	
0001bb 9508                      	ret
                                 
                                 wire1_read:
0001bc 933f                      	push	a1
0001bd e038                      	ldi	a1,8
0001be 9527                      	ror	a0
0001bf dfe6                      	rcall	wire1_read1			; returns result in T
0001c0 f927                      	bld	a0,7					; move T to MSb
0001c1 953a
0001c2 f7d9                      	DJNZ	a1,wire1_read+2		; dec and jump if not zero
0001c3 913f                      	pop	a1	
0001c4 9508                      	ret
                                 	
                                 wire1_crc:
0001c5 e109                      	ldi	w,0b00011001
0001c6 e048                      	ldi	a2,8
0001c7 9527                      crc1:	ror	a0
0001c8 f408                      	brcc	PC+2
0001c9 2730                      	eor	a1,w
0001ca fb30                      	bst	a1,0
0001cb 9537                      	ror	a1
0001cc f937                      	bld	a1,7
0001cd 954a
0001ce f7c1                      	DJNZ	a2,crc1
                                             .include "ws2812_driver.asm"
0001cf 9508                      
                                 ; purpose: reusable bit-bang driver + 88 XY helpers for WS2812B
                                 ;
                                 ; ????? ROUTINE REGISTER-USAGE SUMMARY (after this patch) ?????????????
                                 ;  routine         reads            clobbers (caller must save)       
                                 ; ?????????????????????????????????????????????????????????????????????
                                 ;  ws_init                                                          
                                 ;  ws_byte3wr      a0 a1 a2         a0 a1 a2          (u,w are saved) 
                                 ;  ws_reset                                                         
                                 ;  ws_idx_xy       r24 r25          r24 u                            
                                 ;  ws_offset_idx   r24              u w ZL ZH                        
                                 ;  (SREG always changes as any normal arithmetic will.)               
                                 ; ?????????????????????????????????????????????????????????????????????
                                 ; WS_PUSH_ALL    push every register any of the public helpers
                                 ;                    (ws_byte3wr, ws_idx_xy, ws_offset_idx) may change.
                                 ;   WS_POP_ALL     restore them in reverse order.
                                 ;
                                 ;  Use pattern
                                 ;       WS_PUSH_ALL
                                 ;           ;  build / send frame here 
                                 ;       WS_POP_ALL
                                 ; If your code needs a0a2 kept, push them before calling ws_byte3wr.
                                 ;
                                 ; ????? pin configuration (override before .include if you wish) ?????
                                 .equ WS_PORT_REG = PORTD
                                 .equ WS_DDR_REG  = DDRD
                                 .equ WS_PIN_IDX  = 7
                                 .equ WS_PIN_MASK = (1 << WS_PIN_IDX)
                                 
                                 .equ WS_BUF_BASE = 0x0400          ; 883-byte frame buffer
                                         .macro WS_PUSH_ALL
                                             push    a0
                                             push    a1
                                             push    a2
                                             push    u
                                             push    w
                                             push    r24
                                             push    r25
                                             push    ZH
                                             push    ZL
                                         .endm
                                 
                                         .macro WS_POP_ALL
                                             pop     ZL
                                             pop     ZH
                                             pop     r25
                                             pop     r24
                                             pop     w
                                             pop     u
                                             pop     a2
                                             pop     a1
                                             pop     a0
                                         .endm
                                 ; ????? timing-critical bit macros (4 MHz) ????????????????????????????
                                 ; 0 bit total ? 5 cycles (T0H ? 0.40 s, T0L ? 0.85 s)
                                 .macro WS_WR0
                                     clr  u                          ; u = 0  (destroys u **inside** routine)
                                     sbi  WS_PORT_REG, WS_PIN_IDX    ; high     (2 cy)
                                     out  WS_PORT_REG, u             ; low      (1 cy) full-port write
                                     nop                              ; 1 cy
                                     nop                              ; 1 cy
                                 .endm
                                 ; 1 bit total ? 8 cycles (T1H ? 0.80 s, T1L ? 0.45 s)
                                 .macro WS_WR1
                                     sbi  WS_PORT_REG, WS_PIN_IDX    ; high   (2 cy)
                                     nop                              ; 1 cy
                                     nop                              ; 1 cy
                                     cbi  WS_PORT_REG, WS_PIN_IDX    ; low    (2 cy)
                                 .endm
                                 
                                 ; ????????????????? PUBLIC ROUTINES ???????????????????????????????????
                                 
                                 ; set the data pin as output
                                 ws_init:
0001d0 e800
0001d1 bb01                          OUTI WS_DDR_REG, WS_PIN_MASK
0001d2 9508                          ret
                                 
                                 ; bit-bang three bytes  (G=a0, R=a1, B=a2)
                                 ; u & w pushed so the caller never sees them modified
                                 ws_byte3wr:
0001d3 923f                          push  u
0001d4 930f                          push  w
                                 
                                     ; ? byte G (a0) ?
0001d5 e008                          ldi   w, 8
                                 _b0:
0001d6 fd27                          sbrc  a0, 7
0001d7 c006                              rjmp _b0_1
0001d8 2433
0001d9 9a97
0001da ba32
0001db 0000
0001dc 0000                          WS_WR0
0001dd c004                          rjmp  _b0_next
                                 _b0_1:
0001de 9a97
0001df 0000
0001e0 0000
0001e1 9897                          WS_WR1
                                 _b0_next:
0001e2 0f22                          lsl   a0
0001e3 950a                          dec   w
0001e4 f789                          brne  _b0
                                 
                                     ; ? byte R (a1) ?
0001e5 e008                          ldi   w, 8
                                 _b1:
0001e6 fd37                          sbrc  a1, 7
0001e7 c006                              rjmp _b1_1
0001e8 2433
0001e9 9a97
0001ea ba32
0001eb 0000
0001ec 0000                          WS_WR0
0001ed c004                          rjmp  _b1_next
                                 _b1_1:
0001ee 9a97
0001ef 0000
0001f0 0000
0001f1 9897                          WS_WR1
                                 _b1_next:
0001f2 0f33                          lsl   a1
0001f3 950a                          dec   w
0001f4 f789                          brne  _b1
                                 
                                     ; ? byte B (a2) ?
0001f5 e008                          ldi   w, 8
                                 _b2:
0001f6 fd47                          sbrc  a2, 7
0001f7 c006                              rjmp _b2_1
0001f8 2433
0001f9 9a97
0001fa ba32
0001fb 0000
0001fc 0000                          WS_WR0
0001fd c004                          rjmp  _b2_next
                                 _b2_1:
0001fe 9a97
0001ff 0000
000200 0000
000201 9897                          WS_WR1
                                 _b2_next:
000202 0f44                          lsl   a2
000203 950a                          dec   w
000204 f789                          brne  _b2
                                 
000205 910f                          pop   w
000206 903f                          pop   u
000207 9508                          ret
                                 
                                 ; hold the data line low ?50 s to latch the frame
                                 ws_reset:
000208 9897                          cbi  WS_PORT_REG, WS_PIN_IDX
000209 e401
00020a 2e30
00020b e001
00020c 943a
00020d f7f1
00020e 943a
00020f 950a
000210 f7d9                          WAIT_US 50
000211 9508                          ret
                                 
                                 ; r24=x, r25=y  ? r24 = x + 8y   (clobbers u, r24)
                                 ws_idx_xy:
000212 2e39                          mov  u, r25
000213 0c33                          lsl  u
000214 0c33                          lsl  u
000215 0c33                          lsl  u
000216 0d83                          add  r24, u
000217 9508                          ret
                                 
                                 ; r24=index ? Z = WS_BUF_BASE + 3index  (clobbers u, w, ZL, ZH)
                                 ws_offset_idx:
000218 2f08                          mov  w, r24                  ; w = idx
000219 0f00                          lsl  w                       ; w = 2idx
00021a 2e38                          mov  u, r24
00021b 0d03                          add  w, u                    ; w = 3idx
00021c e0e0                          ldi  ZL, low (WS_BUF_BASE)
00021d e0f4                          ldi  ZH, high(WS_BUF_BASE)
00021e 0fe0                          add  ZL, w
00021f 2433                          clr  u
000220 1df3                          adc  ZH, u                   ; add carry
                                 			.include "encoder.asm"
000221 9508                      
                                 ; purpose library angular encoder operation
                                 
                                 ; === definitions ===
                                 .equ	ENCOD	= PORTE
                                 
                                 .dseg
000104                           enc_old:.byte	1
                                 .cseg
                                 
                                 ; === routines ===
                                 
                                 encoder_init:
000222 b102                      	in	w,ENCOD-1		; make 3 lines input
000223 780f                      	andi	w,0b10001111
000224 b902                      	out	ENCOD-1,w
000225 b103                      	in	w,ENCOD			; enable 3 internal pull-ups
000226 6700                      	ori	w,0b01110000
000227 b903                      	out	ENCOD,w
000228 9508                      	ret
                                 
                                 encoder:
                                 ; a0,b0	if button=up   then increment/decrement a0	 
                                 ; a0,b0	if button=down then incremnt/decrement b0 
                                 ; T 	T=1 button press (transition up-down)
                                 ; Z	Z=1 button down change
                                 
000229 94e8                      	clt						; preclear T
00022a b111                      	in	_w,ENCOD-2			; read encoder port (_w=new)
                                 	
00022b 7710                      	andi	_w,0b01110000	; mask encoder lines (A,B,I)
00022c 9020 0104                 	lds	_u,enc_old			; load prevous value (_u=old)
00022e 1512                      	cp	_w,_u				; compare new<>old ?
00022f f411                      	brne	PC+3
000230 9498                      	clz
000231 9508                      	ret						; if new=old then return (Z=0)
000232 9310 0104                 	sts	enc_old,_w			; store encoder value for next time
                                 
000234 2621                      	eor	_u,_w				; exclusive or detects transitions
000235 9498                      	clz						; clear Z flag
000236 fc26                      	sbrc	_u,ENCOD_I
000237 c020                      	rjmp	encoder_button	; transition on I (button)
000238 fe24                      	sbrs	_u,ENCOD_A
000239 9508                      	ret						; return (no transition on I or A)	
                                 
00023a ff16                      	sbrs	_w,ENCOD_I		; is the button up or down ?
00023b c00b                      	rjmp	i_down
                                 i_up:	
00023c fd14                      	sbrc	_w,ENCOD_A
00023d c004                      	rjmp	a_rise
                                 a_fall:
00023e 9523                      	inc	a0					; if B=1 then increment
00023f ff15                      	sbrs	_w,ENCOD_B
000240 5022                      	subi	a0,2			; if B=0 then decrement
000241 c003                      	rjmp	i_up_done
                                 a_rise:
000242 9523                      	inc	a0					; if B=0 then increment
000243 fd15                      	sbrc	_w,ENCOD_B
000244 5022                      	subi	a0,2			; if B=1 then decrement
                                 i_up_done:
000245 9498                      	clz						; clear Z
000246 9508                      	ret
                                 
                                 i_down:	
000247 fd14                      	sbrc	_w,ENCOD_A
000248 c004                      	rjmp	a_rise2
                                 a_fall2:
000249 9563                      	inc	b0					; if B=1 then increment
00024a ff15                      	sbrs	_w,ENCOD_B
00024b 5062                      	subi	b0,2			; if B=0 then decrement
00024c c003                      	rjmp	i_down_done
                                 a_rise2:
00024d 9563                      	inc	b0					; if B=0 then increment
00024e fd15                      	sbrc	_w,ENCOD_B
00024f 5062                      	subi	b0,2			; if B=1 then decrement
                                 i_down_done:
000250 9418                      	sez						; set Z
000251 9508                      	ret
                                 
                                 encoder_update:
                                     ; save old a0
000252 2f02                          mov r16, a0
                                 
                                     ; call the existing routine
000253 dfd5                          rcall encoder
                                 
                                     ; now a0 = new count, r16 = old count
000254 2f12                          mov r17, a0
                                     ; compute ? = new ? old
000255 1b10                          sub r17, r16       ; r17 = a0_new ? a0_old
000256 2e31                          mov r3, r17        ; put result in r3
                                 
000257 9508                          ret
                                 
                                 encoder_button:
000258 fd16                      	sbrc	_w,ENCOD_I
000259 c002                      	rjmp	i_rise
                                 i_fall:
00025a 9468                      	set						; set T=1 to indicate button press
00025b 9508                      	ret
                                 i_rise:
00025c 9508                      	ret
                                 
                                 .macro	CYCLIC	;reg,lo,hi
                                 	cpi	@0,@1-1
                                 	brne	PC+2
                                 	ldi	@0,@2
                                 	cpi	@0,@2+1
                                 	brne	PC+2
                                 	ldi	@0,@1
                                 .endmacro
                                 			.include "ws2812_helpers.asm"
                                 
                                 ;  ws2812_helpers.asm    simple drawing helpers for the 88 framebuffer
                                 ;   relies on the low-level driver in ws2812_driver.asm
                                 ;   does NO I/O-port touching  only SRAM work + ws_byte3wr / ws_reset
                                 ;======================================================================
                                 
                                 
                                 ;----------------------------------------------------------------------
                                 ;  ws_fill_color   paint entire 88 buffer with colour (a0,a1,a2)
                                 ;    destroys: r18, ZL, ZH        (all others preserved)
                                 ;----------------------------------------------------------------------
                                 ws_fill_color:
00025d 932f                                  push r18
00025e 932f
00025f 933f
000260 934f
000261 923f
000262 930f
000263 938f
000264 939f
000265 93ff
000266 93ef                                  WS_PUSH_ALL              ; keep callers working regs safe
                                 
000267 e0e0                                  ldi   ZL, low (WS_BUF_BASE)
000268 e0f4                                  ldi   ZH, high(WS_BUF_BASE)
000269 e420                                  ldi   r18, 64            ; 64 pixels
                                 fill_loop:
00026a 9321                                  st    Z+, a0             ; G
00026b 9331                                  st    Z+, a1             ; R
00026c 9341                                  st    Z+, a2             ; B
00026d 952a                                  dec   r18
00026e f7d9                                  brne  fill_loop
                                 
00026f 91ef
000270 91ff
000271 919f
000272 918f
000273 910f
000274 903f
000275 914f
000276 913f
000277 912f                                  WS_POP_ALL
000278 912f                                  pop  r18
000279 9508                                  ret
                                 
                                 ;----------------------------------------------------------------------
                                 ;  ws_plot_xy   write one pixel
                                 ;       in:  r24 = x (0-7),  r25 = y (0-7),  a0/a1/a2 = G/R/B
                                 ;----------------------------------------------------------------------
                                 ws_plot_xy:
00027a 932f
00027b 933f
00027c 934f
00027d 923f
00027e 930f
00027f 938f
000280 939f
000281 93ff
000282 93ef                                  WS_PUSH_ALL
000283 93ef                                  push  ZL
000284 93ff                                  push  ZH
000285 930f                                  push  w
000286 923f                                  push  u
                                 
000287 df8a                                  rcall ws_idx_xy          ; r24 ? index 0-63
000288 df8f                                  rcall ws_offset_idx      ; Z ? address of GRB triplet
000289 9321                                  st    Z+, a0
00028a 9331                                  st    Z+, a1
00028b 8340                                  st    Z , a2
                                 
00028c 903f                                  pop   u
00028d 910f                                  pop   w
00028e 91ff                                  pop   ZH
00028f 91ef                                  pop   ZL
000290 91ef
000291 91ff
000292 919f
000293 918f
000294 910f
000295 903f
000296 914f
000297 913f
000298 912f                                  WS_POP_ALL
000299 9508                                  ret
                                 
                                 ;----------------------------------------------------------------------
                                 ;  ws_show_frame   send the whole buffer to the LEDs
                                 ;----------------------------------------------------------------------
                                 ws_show_frame:
00029a 932f
00029b 933f
00029c 934f
00029d 923f
00029e 930f
00029f 938f
0002a0 939f
0002a1 93ff
0002a2 93ef                                  WS_PUSH_ALL
                                 
0002a3 e0e0                                  ldi   ZL, low (WS_BUF_BASE)
0002a4 e0f4                                  ldi   ZH, high(WS_BUF_BASE)
0002a5 e420                                  ldi   r18, 64
                                 show_loop:
0002a6 9121                                  ld    a0, Z+
0002a7 9131                                  ld    a1, Z+
0002a8 9141                                  ld    a2, Z+
0002a9 94f8                                  cli
0002aa df28                                  rcall ws_byte3wr         ; driver saves/restores u & w
0002ab 9478                                  sei
0002ac 952a                                  dec   r18
0002ad f7c1                                  brne  show_loop
0002ae df59                                  rcall ws_reset
                                 
0002af 91ef
0002b0 91ff
0002b1 919f
0002b2 918f
0002b3 910f
0002b4 903f
0002b5 914f
0002b6 913f
0002b7 912f                                  WS_POP_ALL
0002b8 9508                                  ret
                                 
                                 delayFrame:
0002b9 ec08
0002ba 2e30
0002bb e001
0002bc 930f
0002bd 923f
0002be e300
0002bf 2e30
0002c0 e006
0002c1 943a
0002c2 f7f1
0002c3 943a
0002c4 950a
0002c5 f7d9
0002c6 903f
0002c7 910f
0002c8 943a
0002c9 f791
0002ca 950a
0002cb f781                              WAIT_MS 200            ; macro lives here, not in state loops
0002cc e302
0002cd 2e30
0002ce e001
0002cf 930f
0002d0 923f
0002d1 e300
0002d2 2e30
0002d3 e006
0002d4 943a
0002d5 f7f1
0002d6 943a
0002d7 950a
0002d8 f7d9
0002d9 903f
0002da 910f
0002db 943a
0002dc f791
0002dd 950a
0002de f781                              WAIT_MS 50             ; small extra so LCD has time to settle
0002df 9508                      ;----------------------------------------------------------------------
                                 ;  State modules
                                 ;----------------------------------------------------------------------
                                             .include "home_state.asm"
                                 
                                 ;  Home screen   ST_HOME
                                 ;======================================================================
                                 
                                 home_init:
0002e0 932f                              push  r18
0002e1 933f                              push  r19
0002e2 dd52                              rcall lcd_clear
0002e3 d003                              rcall home_loop
0002e4 913f                              pop   r19
0002e5 912f                              pop   r18
0002e6 9508                              ret
                                 
                                 ;----------------------------------------------------------------------
                                 home_loop:
                                 loopHome:
                                         ;---- LCD -----------------------------------------------------
0002e7 dd4d                              rcall lcd_clear
0002e8 e209
0002e9 2e40
0002ea e000
0002eb 2e50
0002ec dd7a                              PRINTF LCD
0002ed 6f48
0002ee 656d
0002ef 0000                              .db "Home",0,0
                                 
                                         ;---- Matrix : dim white -------------------------------------
0002f0 932f
0002f1 933f
0002f2 934f
0002f3 923f
0002f4 930f
0002f5 938f
0002f6 939f
0002f7 93ff
0002f8 93ef                              WS_PUSH_ALL
0002f9 e023                                  ldi  a0,0x03
0002fa e033                                  ldi  a1,0x03
0002fb e043                                  ldi  a2,0x03
0002fc df60                                  rcall ws_fill_color
0002fd df9c                                  rcall ws_show_frame
0002fe 91ef
0002ff 91ff
000300 919f
000301 918f
000302 910f
000303 903f
000304 914f
000305 913f
000306 912f                              WS_POP_ALL
                                 
                                         ;---- housekeeping -------------------------------------------
000307 ed04
000308 2e30
000309 e009
00030a 943a
00030b f7f1
00030c 943a
00030d 950a
00030e f7d9                              WAIT_US 100000
00030f 9120 0100                         lds   r18,flags
000311 fd20                              sbrc  r18,FLG_TEMP
000312 d1a2                              rcall temp_task
000313 e209
000314 2e30
000315 e609
000316 943a
000317 f7f1
000318 943a
000319 950a
00031a f7d9                              WAIT_US 20000
                                 
                                         ;---- stay in this state? ------------------------------------
00031b 2d36                              mov   r19,sel
00031c 3030                              cpi   r19,ST_HOME
00031d f409                              brne  exitHome              ; *** long-range fix
00031e cfc8                              rjmp  loopHome
                                 exitHome:                            ; ***
                                             .include "snake_state.asm"
00031f 9508                      
                                 ;  Snake   ST_GAME1
                                 ;======================================================================
                                 
                                 snake_init:
000320 932f                              push  r18
000321 933f                              push  r19
000322 dd12                              rcall lcd_clear
000323 d003                              rcall snake_loop
000324 913f                              pop   r19
000325 912f                              pop   r18
000326 9508                              ret
                                 
                                 ;----------------------------------------------------------------------
                                 snake_loop:
                                 loopSnake:
                                         ;---- LCD -----------------------------------------------------
000327 dd0d                              rcall lcd_clear
000328 e209
000329 2e40
00032a e000
00032b 2e50
00032c dd3a                              PRINTF LCD
00032d 6e53
00032e 6b61
00032f 0065
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm(20): warning: .cseg .db misalignment - padding zero byte
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(66): 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\snake_state.asm' included form here
000330 0000                              .db "Snake",0,0
                                 
                                         ;---- Matrix --------------------------------------------------
000331 932f
000332 933f
000333 934f
000334 923f
000335 930f
000336 938f
000337 939f
000338 93ff
000339 93ef                              WS_PUSH_ALL
                                             ; black background
00033a e020                                  ldi  a0,0
00033b e030                                  ldi  a1,0
00033c e040                                  ldi  a2,0
00033d df1f                                  rcall ws_fill_color
                                 
                                             ; horizontal green bar (row 3)
00033e e120                                  ldi  a0,0x10
00033f e030                                  ldi  a1,0x00
000340 e040                                  ldi  a2,0x00
000341 e093                                  ldi  r25,3
000342 e080                                  ldi  r24,0
                                 drawBar:
000343 df36                                  rcall ws_plot_xy
000344 9583                                  inc   r24
000345 3088                                  cpi   r24,8
000346 f3e0                                  brlo  drawBar
                                 
000347 df52                                  rcall ws_show_frame
000348 91ef
000349 91ff
00034a 919f
00034b 918f
00034c 910f
00034d 903f
00034e 914f
00034f 913f
000350 912f                              WS_POP_ALL
                                 
                                         ;---- housekeeping -------------------------------------------
000351 ed04
000352 2e30
000353 e009
000354 943a
000355 f7f1
000356 943a
000357 950a
000358 f7d9                              WAIT_US 100000
000359 9120 0100                         lds   r18,flags
00035b fd20                              sbrc  r18,FLG_TEMP
00035c d158                              rcall temp_task
00035d e209
00035e 2e30
00035f e609
000360 943a
000361 f7f1
000362 943a
000363 950a
000364 f7d9                              WAIT_US 20000
                                 
                                         ;---- stay in this state? ------------------------------------
000365 2d36                              mov   r19,sel
000366 3031                              cpi   r19,ST_GAME1
000367 f409                              brne  exitSnake            ; *** long-range fix
000368 cfbe                              rjmp  loopSnake
                                 exitSnake:                          ; ***
                                             .include "game2_state.asm"
000369 9508                      
                                 ;  Game-2   ST_GAME2   (blue X)
                                 ;======================================================================
                                 
                                 gameTwoInit:
00036a 932f                              push  r18
00036b 933f                              push  r19
00036c dcc8                              rcall lcd_clear
00036d d003                              rcall gameTwoLoop
00036e 913f                              pop   r19
00036f 912f                              pop   r18
000370 9508                              ret
                                 
                                 ;----------------------------------------------------------------------
                                 gameTwoLoop:
                                 loopGameTwo:
                                         ;---- LCD -----------------------------------------------------
000371 dcc3                              rcall lcd_clear
000372 e209
000373 2e40
000374 e000
000375 2e50
000376 dcf0                              PRINTF LCD
000377 6147
000378 656d
000379 0032
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm(20): warning: .cseg .db misalignment - padding zero byte
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(67): 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game2_state.asm' included form here
00037a 0000                              .db "Game2",0,0
                                 
                                         ;---- Matrix --------------------------------------------------
00037b 932f
00037c 933f
00037d 934f
00037e 923f
00037f 930f
000380 938f
000381 939f
000382 93ff
000383 93ef                              WS_PUSH_ALL
                                             ; clear black
000384 e020                                  ldi  a0,0
000385 e030                                  ldi  a1,0
000386 e040                                  ldi  a2,0
000387 ded5                                  rcall ws_fill_color
                                 
                                             ; blue X
000388 e020                                  ldi  a0,0x00
000389 e030                                  ldi  a1,0x00
00038a e140                                  ldi  a2,0x10
00038b e090                                  ldi  r25,0
                                 rowsX:
00038c 2f89                                  mov  r24,r25
00038d deec                                  rcall ws_plot_xy
00038e e087                                  ldi  r24,7
00038f 1b89                                  sub  r24,r25
000390 dee9                                  rcall ws_plot_xy
000391 9593                                  inc  r25
000392 3098                                  cpi  r25,8
000393 f3c0                                  brlo rowsX
                                 
000394 df05                                  rcall ws_show_frame
000395 91ef
000396 91ff
000397 919f
000398 918f
000399 910f
00039a 903f
00039b 914f
00039c 913f
00039d 912f                              WS_POP_ALL
                                 
                                         ;---- housekeeping -------------------------------------------
00039e ed04
00039f 2e30
0003a0 e009
0003a1 943a
0003a2 f7f1
0003a3 943a
0003a4 950a
0003a5 f7d9                              WAIT_US 100000
0003a6 9120 0100                         lds   r18,flags
0003a8 fd20                              sbrc  r18,FLG_TEMP
0003a9 d10b                              rcall temp_task
0003aa e209
0003ab 2e30
0003ac e609
0003ad 943a
0003ae f7f1
0003af 943a
0003b0 950a
0003b1 f7d9                              WAIT_US 20000
                                 
                                         ;---- stay in this state? ------------------------------------
0003b2 2d36                              mov   r19,sel
0003b3 3032                              cpi   r19,ST_GAME2
0003b4 f409                              brne  exitGameTwo          ; *** long-range fix
0003b5 cfbb                              rjmp  loopGameTwo
                                 exitGameTwo:                        ; ***
                                             .include "game3_state.asm"
0003b6 9508                      
                                 ;  Game-3   ST_GAME3   (green square)
                                 ;======================================================================
                                 
                                 gameThreeInit:
0003b7 932f                              push  r18
0003b8 933f                              push  r19
0003b9 dc7b                              rcall lcd_clear
0003ba d003                              rcall gameThreeLoop
0003bb 913f                              pop   r19
0003bc 912f                              pop   r18
0003bd 9508                              ret
                                 
                                 ;----------------------------------------------------------------------
                                 gameThreeLoop:
                                 loopGameThree:
                                         ;---- LCD -----------------------------------------------------
0003be dc76                              rcall lcd_clear
0003bf e209
0003c0 2e40
0003c1 e000
0003c2 2e50
0003c3 dca3                              PRINTF LCD
0003c4 6147
0003c5 656d
0003c6 0033
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm(20): warning: .cseg .db misalignment - padding zero byte
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(68): 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\game3_state.asm' included form here
0003c7 0000                              .db "Game3",0,0
                                 
                                         ;---- Matrix --------------------------------------------------
0003c8 932f
0003c9 933f
0003ca 934f
0003cb 923f
0003cc 930f
0003cd 938f
0003ce 939f
0003cf 93ff
0003d0 93ef                              WS_PUSH_ALL
                                             ; clear
0003d1 e020                                  ldi  a0,0
0003d2 e030                                  ldi  a1,0
0003d3 e040                                  ldi  a2,0
0003d4 de88                                  rcall ws_fill_color
                                 
                                             ; 33 green block
0003d5 e120                                  ldi  a0,0x10
0003d6 e030                                  ldi  a1,0x00
0003d7 e040                                  ldi  a2,0x00
0003d8 e092                                  ldi  r25,2
                                 rowsSq:
0003d9 e082                                  ldi  r24,2
                                 colsSq:
0003da de9f                                  rcall ws_plot_xy
0003db 9583                                  inc   r24
0003dc 3085                                  cpi   r24,5
0003dd f3e0                                  brlo  colsSq
0003de 9593                                  inc   r25
0003df 3095                                  cpi   r25,5
0003e0 f3c0                                  brlo  rowsSq
                                 
0003e1 deb8                                  rcall ws_show_frame
0003e2 91ef
0003e3 91ff
0003e4 919f
0003e5 918f
0003e6 910f
0003e7 903f
0003e8 914f
0003e9 913f
0003ea 912f                              WS_POP_ALL
                                 
                                         ;---- housekeeping -------------------------------------------
0003eb ed04
0003ec 2e30
0003ed e009
0003ee 943a
0003ef f7f1
0003f0 943a
0003f1 950a
0003f2 f7d9                              WAIT_US 100000
0003f3 9120 0100                         lds   r18,flags
0003f5 fd20                              sbrc  r18,FLG_TEMP
0003f6 d0be                              rcall temp_task
0003f7 e209
0003f8 2e30
0003f9 e609
0003fa 943a
0003fb f7f1
0003fc 943a
0003fd 950a
0003fe f7d9                              WAIT_US 20000
                                 
                                         ;---- stay in this state? ------------------------------------
0003ff 2d36                              mov   r19,sel
000400 3033                              cpi   r19,ST_GAME3
000401 f409                              brne  exitGameThree        ; *** long-range fix
000402 cfbb                              rjmp  loopGameThree
                                 exitGameThree:                      ; ***
                                             .include "doctor_state.asm"
000403 9508                      
                                 ;  Doctor mode   ST_DOCTOR
                                 ;======================================================================
                                 
                                 doctorInit:
000404 932f                              push  r18
000405 dc2f                              rcall lcd_clear
000406 d002                              rcall doctorLoop
000407 912f                              pop   r18
000408 9508                              ret
                                 
                                 ;----------------------------------------------------------------------
                                 doctorLoop:
                                 loopDoctor:
                                         ;---- background temperature ---------------------------------
000409 9120 0100                         lds  r18,flags
00040b fd20                              sbrc r18,FLG_TEMP
00040c d0a8                              rcall temp_task
                                 
                                         ;---- LCD -----------------------------------------------------
00040d dc27                              rcall lcd_clear
00040e 9120 0101                         lds  a0,temp_lsb
000410 9130 0102                         lds  a1,temp_msb
000412 e209
000413 2e40
000414 e000
000415 2e50
000416 dc50                              PRINTF LCD
000417 6f44
000418 7463
000419 726f
00041a 8b20
00041b 0412
00041c 4342
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm(25): warning: .cseg .db misalignment - padding zero byte
Z:\medical_consol_atmega128\medical_thermo\medical_thermo\main.asm(69): 'Z:\medical_consol_atmega128\medical_thermo\medical_thermo\doctor_state.asm' included form here
00041d 0000                              .db "Doctor ",FFRAC2+FSIGN,a,4,$42,"C",0
                                 
                                         ;---- Matrix --------------------------------------------------
00041e 932f
00041f 933f
000420 934f
000421 923f
000422 930f
000423 938f
000424 939f
000425 93ff
000426 93ef                              WS_PUSH_ALL
000427 e020                                  ldi  a0,0
000428 e030                                  ldi  a1,0
000429 e040                                  ldi  a2,0
00042a de32                                  rcall ws_fill_color
                                 
00042b 9160 0101                             lds  r22,temp_lsb
00042d 9566                                  lsr  r22
00042e 3460                                  cpi  r22,64
00042f f008                                  brlo bucketOk
000430 e36f                                  ldi  r22,63
                                 bucketOk:
000431 e087                                  ldi  r24,7
000432 e097                                  ldi  r25,7
                                 thermLoop:
000433 3094                                  cpi  r25,4
000434 f018                                  brlo greenPart
                                 redPart:
000435 e020                                  ldi  a0,0
000436 e130                                  ldi  a1,0x10
000437 c002                                  rjmp colourDone
                                 greenPart:
000438 e120                                  ldi  a0,0x10
000439 e030                                  ldi  a1,0
                                 colourDone:
00043a e040                                  ldi  a2,0
00043b de3e                                  rcall ws_plot_xy
00043c 959a                                  dec  r25
00043d 956a                                  dec  r22
00043e f7a2                                  brpl thermLoop
                                 
00043f de5a                                  rcall ws_show_frame
000440 91ef
000441 91ff
000442 919f
000443 918f
000444 910f
000445 903f
000446 914f
000447 913f
000448 912f                              WS_POP_ALL
                                 
                                         ;---- housekeeping -------------------------------------------
000449 ed04
00044a 2e30
00044b e009
00044c 943a
00044d f7f1
00044e 943a
00044f 950a
000450 f7d9                              WAIT_US 100000
000451 e209
000452 2e30
000453 e609
000454 943a
000455 f7f1
000456 943a
000457 950a
000458 f7d9                              WAIT_US 20000
                                 
000459 2d26                              mov   r18,sel
00045a 3024                              cpi   r18,ST_DOCTOR
00045b f409                              brne  exitDoctor           ; *** long-range fix
00045c cfac                              rjmp  loopDoctor
                                 exitDoctor:                         ; ***
00045d 9508                      ;======================================================================
                                 ;  RESET sequence
                                 ;======================================================================
                                 reset:
00045e ef0f
00045f bf0d
000460 e100
000461 bf0e                                  LDSP  RAMEND
000462 dbe6                                  rcall LCD_init
000463 dd1e                                  rcall wire1_init
                                 			; WS2812 matrix on PD7 -----------------------------------------------
                                    
                                 ; Buttons PD0PD3: inputs w/ pull-ups -------------------------------
000464 9888                                  cbi   DDRD,0
000465 9889                                  cbi   DDRD,1
000466 988a                                  cbi   DDRD,2
000467 988b                                  cbi   DDRD,3
000468 9a90                                  sbi   PORTD,0
000469 9a91                                  sbi   PORTD,1
00046a 9a92                                  sbi   PORTD,2
00046b 9a93                                  sbi   PORTD,3
00046c dd63                      			rcall ws_init
                                 ; LED-strip on PF7 (active-low) --------------------------------------
00046d 9100 0061                             lds   r16,DDRF
00046f 6800                                  ori   r16,(1<<LED_BIT)
000470 9300 0061                             sts   DDRF,r16           ; PF7 = output
000472 9100 0062                             lds   r16,PORTF
000474 6800                                  ori   r16,(1<<LED_BIT)
000475 9300 0062                             sts   PORTF,r16          ; LED off
                                 
                                 ; WS2812 matrix on PD7 -----------------------------------------------
000477 9897                                  cbi   PORTD,7            ; ensure low until ws_init
                                 
                                 ; Timer-1 one-second tick --------------------------------------------
000478 ef00                                  ldi   r16,T1_PREH
000479 bd0d                                  out   TCNT1H,r16
00047a eb0e                                  ldi   r16,T1_PREL
00047b bd0c                                  out   TCNT1L,r16
00047c e005                                  ldi   r16,(1<<CS12)|(1<<CS10)
00047d bd0e                                  out   TCCR1B,r16
00047e e004
00047f bf07                                  OUTI  TIMSK,(1<<TOIE1)
                                 
                                 ; INT0INT3 falling-edge config -------------------------------------
000480 ea0a
000481 9300 006a                             OUTEI EICRA,0b10101010
000483 e00f
000484 bf09                                  OUTI  EIMSK,0b00001111
                                 
000485 9478                                  sei
                                 
                                 ; Initialize WS2812 driver ------------------------------------------
000486 dd49                                  rcall ws_init
                                 
                                 ; Kick off first DS18B20 conversion ---------------------------------
000487 2700                                  clr   r16
000488 9300 0103                             sts   phase,r16
00048a d014                                  rcall temp_convert
                                 
00048b 2466                                  clr   sel              ; start at Home
                                 
                                 ;======================================================================
                                 ;  MAIN LOOP  state dispatch
                                 ;======================================================================
                                 ; === main.asm (excerpt  only the dispatch section changed) ==========
                                 ; --- dispatch table --------------------------------------------------
                                 main_loop:
                                 switch:
00048c 2d06                              mov   r16,sel
                                 
00048d 3000                              cpi   r16,ST_HOME
00048e f411                              brne  swSnake
00048f de50                              rcall home_init
000490 cffb                              rjmp  switch
                                 
                                 swSnake:
000491 3001                              cpi   r16,ST_GAME1
000492 f411                              brne  swGameTwo
000493 de8c                              rcall snake_init
000494 cff7                              rjmp  switch
                                 
                                 swGameTwo:
000495 3002                              cpi   r16,ST_GAME2
000496 f411                              brne  swGameThree
000497 ded2                              rcall gameTwoInit            ; *** label changed
000498 cff3                              rjmp  switch
                                 
                                 swGameThree:
000499 3003                              cpi   r16,ST_GAME3
00049a f411                              brne  swDoctor
00049b df1b                              rcall gameThreeInit          ; *** label changed
00049c cfef                              rjmp  switch
                                 
                                 swDoctor:
00049d df66                              rcall doctorInit             ; *** colon removed
00049e cfed                              rjmp  switch
                                 ; ====================================================================
                                 
                                 ;======================================================================
                                 ;  1-Wire helpers
                                 ;======================================================================
                                 temp_convert:
00049f 930f                                  push  r16
0004a0 dce4                                  rcall wire1_reset
0004a1 ec2c                                  ldi   a0,skipROM
0004a2 dd0e                                  rcall wire1_write
0004a3 e424                                  ldi   a0,convertT
0004a4 dd0c                                  rcall wire1_write
0004a5 910f                                  pop   r16
0004a6 9508                                  ret
                                 
                                 temp_fetch:
0004a7 930f                                  push  r16
0004a8 dcdc                                  rcall wire1_reset
0004a9 ec2c                                  ldi   a0,skipROM
0004aa dd06                                  rcall wire1_write
0004ab eb2e                                  ldi   a0,readScratchpad
0004ac dd04                                  rcall wire1_write
0004ad dd0e                                  rcall wire1_read
0004ae 9320 0101                             sts   temp_lsb,a0
0004b0 dd0b                                  rcall wire1_read
0004b1 9320 0102                             sts   temp_msb,a0
0004b3 910f                                  pop   r16
0004b4 9508                                  ret
                                 
                                 ;----------------------------------------------------------------------
                                 ;  Background temperature task
                                 ;----------------------------------------------------------------------
                                 temp_task:
0004b5 9100 0100                             lds   r16,flags
0004b7 7f0e                                  andi  r16,~(1<<FLG_TEMP)
0004b8 9300 0100                             sts   flags,r16
                                 
0004ba 9100 0103                             lds   r16,phase
0004bc 2300                                  tst   r16
0004bd f029                                  breq  do_convert
                                 
0004be dfe8                                  rcall temp_fetch
0004bf 2700                                  clr   r16
0004c0 9300 0103                             sts   phase,r16
0004c2 9508                                  ret
                                 
                                 do_convert:
0004c3 dfdb                                  rcall temp_convert
0004c4 e001                                  ldi   r16,1
0004c5 9300 0103                             sts   phase,r16
0004c7 9508                                  ret
                                 
                                 ;======================================================================
                                 ;  Interrupt service routines
                                 ;======================================================================
                                 ;-----------------------  INT0  next state  --------------------------
                                 int0_isr:
0004c8 930f                              push  r16
0004c9 9463                              inc   sel
0004ca e004                              ldi   r16,REG_STATES
0004cb 1660                              cp    sel,r16
0004cc f008                              brlo  int0_done
0004cd 2466                              clr   sel                   ; wrap 3?0
                                 int0_done:
0004ce 910f                              pop   r16
0004cf 9518                              reti
                                 
                                 ;-----------------------  INT1  previous state -----------------------
                                 int1_isr:
0004d0 930f                              push  r16
0004d1 2066                              tst   sel
0004d2 f421                              brne  int1_dec
0004d3 e003                              ldi   r16,REG_STATES-1      ; wrap 0?3
0004d4 2e60                              mov   sel,r16
0004d5 910f                              pop   r16
0004d6 9518                              reti
                                 int1_dec:
0004d7 946a                              dec   sel
0004d8 910f                              pop   r16
0004d9 9518                              reti
                                 
                                 ;-----------------------  INT2  goto Home ----------------------------
                                 int2_isr:
0004da 2466                              clr   sel                   ; ST_HOME
0004db 9518                              reti
                                 
                                 ;-----------------------  INT3  Doctor mode --------------------------
                                 int3_isr:
0004dc 930f                              push  r16
0004dd e004                              ldi   r16,ST_DOCTOR
0004de 2e60                              mov   sel,r16
0004df 910f                              pop   r16
0004e0 9518                              reti
                                 
                                 ;-----------------------  Timer-1 overflow  ---------------------------
                                 t1_isr:
0004e1 930f                              push  r16
0004e2 931f                              push  r17
                                 
                                         ; reload counter
0004e3 ef00                              ldi   r16,T1_PREH
0004e4 bd0d                              out   TCNT1H,r16
0004e5 eb0e                              ldi   r16,T1_PREL
0004e6 bd0c                              out   TCNT1L,r16
                                 
                                         ; heartbeat LED on PF7
0004e7 9100 0062                         lds   r16,PORTF
0004e9 e810                              ldi   r17,(1<<LED_BIT)
0004ea 2701                              eor   r16,r17
0004eb 9300 0062                         sts   PORTF,r16
                                 
                                         ; set temperature task flag
0004ed 9100 0100                         lds   r16,flags
0004ef 6001                              ori   r16,(1<<FLG_TEMP)
0004f0 9300 0100                         sts   flags,r16
                                 
0004f2 911f                              pop   r17
0004f3 910f                              pop   r16


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   9 r0 :   7 r1 :   0 r2 :   5 r3 :  85 r4 :   6 
r5 :   6 r6 :  15 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   0 r15:   0 r16: 283 r17:  20 r18: 100 r19:  75 r20:  47 
r21:  15 r22:  18 r23:  25 r24:  36 r25:  44 r26:   4 r27:   4 r28:   0 
r29:   0 r30:  33 r31:  28 
Registers used: 27 out of 35 (77.1%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   5 adiw  :   5 and   :   0 
andi  :  10 asr   :   2 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   0 break :   0 breq  :  17 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   8 brlt  :   0 brmi  :   1 
brne  :  57 brpl  :   2 brsh  :   1 brtc  :   5 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   6 call  :   0 cbi   :  15 cbr   :   0 
clc   :   1 clh   :   0 cli   :   1 cln   :   0 clr   :  19 cls   :   0 
clt   :   2 clv   :   0 clz   :   3 com   :   8 cp    :   3 cpc   :   3 
cpi   :  25 cpse  :   0 dec   :  61 elpm  :   0 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   8 inc   :  11 
jmp   :   6 ld    :   9 ldd   :   0 ldi   : 159 lds   :  18 lpm   :  12 
lsl   :   8 lsr   :   4 mov   :  59 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :  18 or    :   0 ori   :   6 out   :  16 
pop   : 125 push  : 123 rcall : 102 ret   :  52 reti  :   6 rjmp  :  59 
rol   :  10 ror   :  17 sbc   :   3 sbci  :   0 sbi   :  14 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   1 sbrc  :  25 sbrs  :   4 sec   :   0 
seh   :   0 sei   :   2 sen   :   0 ser   :   0 ses   :   0 set   :   2 
sev   :   0 sez   :   1 sleep :   0 spm   :   0 st    :   6 std   :   0 
sts   :  15 sub   :   5 subi  :   7 swap  :   4 tst   :  10 wdr   :   0 

Instructions used: 64 out of 114 (56.1%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0009ea   2458     44   2502  131072   1.9%
[.dseg] 0x000100 0x000105      0      5      5    4096   0.1%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 4 warnings
